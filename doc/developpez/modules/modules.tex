\part{Modules de la bibliothèque standard Nit}

\chapter{Kernel}
Le module |kernel| est à la base de toute la hiérarchie objet de Nit, c'est donc un module de base. Par exemple, il contient les classes fondamentales telles que |Bool|, |Char|, |Float|, |Int|, |Object|...

Faisons un tour rapide des classes principales du module |kernel| :
\begin{description}
    \item[Object]C'est la super classe implicite de toutes les classes en Nit : toutes ces méthodes sont donc héritées par toutes les classes.
    \item[Bool]Représente les booléens. Les seules instances possibles de cette classe sont |true| et |false|. Les booléens sont souvent utilisés dans les branchements conditionnels et les boucles.
    \item[Char]Représente les caractères.
    \item[Comparable]C'est l'ancêtre de toutes les classes dont les instances peuvent être comparées selon un ordre total.
    \item[Discrete]L'ancêtre de toutes les classes représentant des ensembles dénombrables comme les entiers ou l'alphabet.
    \item[Float]Représente les nombres à virgule flottante.
    \item[Int]Représente les nombres entiers.
\end{description}

Les classes du module |kernel| sont fréquemment raffinées dans les autres modules de la bibliothèque standard.

\chapter{String}
Ce module introduit les classes permettant de manipuler les chaînes de caractères.

La classe principale du module string est |String|.

Le module string raffine les classes |Array|, |Collection|, |Float|, |Int|, |Map| et |Object| pour y rajouter la méthode |to_s|.

\chapter{Maths}
Le module math raffine les classes Object, Int et Float pour y rajouter une série de méthodes en rapport avec les mathématiques. Elle est automatiquement importée avec la bibliothèque standard.

\section{Variables mathématiques}
Le module math raffine la classes Object pour lui rajouter la méthode |pi| (3.141592) :
\lstinputlisting[language=Nit]{./modules/listings/pi1_c.nit}

\section{Fonctions trigonométriques}
Les méthodes sin(), cos(), tan(), asin(), acos(), atan() permettent d'effectuer les opérations trigonométriques. Les angles doivent être exprimés en radians. Pour convertir des degrés en radian, il suffit de les multiplier par pi/180.

Exemple :
\lstinputlisting[language=Nit]{./modules/listings/cos1_c.nit}

\section{Exponentielles et puissances}
Les méthodes |pow|, |exp| et |sqrt| permettent de calculer des puissances, des exponentielles et des racines carrées.

Exemple :
\lstinputlisting[language=Nit]{./modules/listings/exp1_c.nit}

\chapter{Collections}
Les collections sont des objets qui permettent de gérer des ensembles d'objets. Ces ensembles de données peuvent être définis avec plusieurs caractéristiques : la possibilité de gérer des doublons, de gérer un ordre de tri, etc. Chaque objet contenu dans une collection est appelé un élément.

Les collections sont basées sur le principe de la généricité que nous avons déjà abordé.

\section{Interfaces des collections}
\subsection{Interface Collection}
Cette interface définit des méthodes pour des objets qui gèrent des éléments d'une façon assez générale. Elle est la super interface de plusieurs interfaces de la bibliothèque standard. Plusieurs classes qui gèrent une collection implémentent une interface qui hérite de l'interface Collection.

Cette interface définit plusieurs méthodes :

\begin{tabularx}{\linewidth}{|c|X|}
    \hline
    Méthode & Rôle \\
    \hline
    count(E):Int & Nombre d'occurrence d'un élément dans une collection. \\
    \hline
    has(E):Bool & Vérifie si un élément se trouve dans la collection. \\
    \hline
    has\_only(E):Bool & Vérifie si la collection contient seulement l'élément précisé. \\
    \hline   
    is\_empty:Bool & Vérifie si la collection est vide. \\
    \hline
    iterate & Itère sur chaque élément de la collection. \\
    \hline
    iterator:Iterator[E] & Retourne un itérateur associé à la collection. \\
    \hline
    length & Retourne le nombre d'élément contenu dans la collection. \\
    \hline
\end{tabularx}

Cette interface représente un minimum commun pour les objets qui gèrent des collections.

\subsection{Interface Iterator}
Cette interface définit des méthodes pour des objets capables de parcourir les données d'une collection :

\begin{tabularx}{\linewidth}{|c|X|}
    \hline
    Méthode & Rôle \\
    \hline
    is\_ok & Indique s'il reste au moins un élément à parcourir dans la collection. \\
    \hline
    item & Renvoie l'élément courant de la collection.  \\
    \hline
    next & Saute au prochain élément de la collection. \\
    \hline
\end{tabularx}

Un exemple d'utilisation de l'iterator :
\lstinputlisting[language=Nit]{./modules/listings/iterator1_s.nit}

\subsection{Interface RemovableCollection}
Cette interface introduit des méthodes permettant de retirer des éléments d'une collection :

\begin{tabularx}{\linewidth}{|c|X|}
    \hline
    Méthode & Rôle \\
    \hline
    clear & Retire tous les éléments de la collection. \\
    \hline
    remove(E) & Retire l'élément précisé de la collection.  \\
    \hline
    remove\_all(E) & Retire toutes les occurrences de l'élément précisé de la collection. \\
    \hline
\end{tabularx}

\subsection{Interface SimpleCollection}
Cette interface introduit des méthodes permettant d'ajouter des éléments dans une collection :

\begin{tabularx}{\linewidth}{|c|X|}
    \hline
    Méthode & Rôle \\
    \hline
    add(E) & Ajoute l'élément dans la collection. \\
    \hline
    add\_all(Collection[E]) & Ajoute tous les éléments dans la collection. \\
    \hline
\end{tabularx}

\section{Séquences}
Les séquences sont des collections indexées et ordonnées. La notion d'index est importante, elle précise que chaque valeur est associée à une sorte d'étiquette numérique permettant de la retrouver. L'ordre de la séquence est donc induit par l'ordre des étiquettes.

L'interface Sequence introduit les méthodes suivantes :

\begin{tabularx}{\linewidth}{|c|X|}
    \hline
    Méthode & Rôle \\
    \hline
    append(Collection[E]) & Ajoute tous les éléments de la collection passée en paramètre à la fin de la séquence. \\
    \hline
    first:E & Retourne le premier élément de la séquence. \\
    \hline
    first=(E) & Définit le premier élément de la séquence. \\
    \hline
    last:E & Retourne le dernier élément de la séquence. \\
    \hline    
    last=(E) & Définit le dernier élément de la séquence. \\
    \hline
    pop:E & Retourne et retire le dernier élément de la séquence. \\
    \hline
    push(E) & Ajoute l'élément à la fin de la séquence. \\
    \hline
    shift:E & Retourne et retire le premier élément de la séquence. \\ 
    \hline
    unshift(E) & Ajoute l'élément au début de la séquence. \\
    \hline
\end{tabularx}

L'interface Sequence est implémentée par les tableaux et les listes.

\subsection{Listes}
Les listes sont des Collections qui autorisent des doublons dans les éléments de la liste, elle acceptent aussi des éléments |null|. Les listes étant aussi des séquences, elles sont donc indexées et ordonnées, un élément de la liste peut donc être accédé directement à partir de son index. C'est aussi une implémentation concrète de Séquence, elle peut donc être instanciée et utilisée directement.

La classe liste représente une liste doublement chaînée : l'ajout d'un élément peut se faire seulement au début ou à la fin de la collection.

Voici un exemple d'utilisation d'une liste :
\lstinputlisting[language=Nit]{./modules/listings/list1_c.nit}

\subsection{Tableaux}
Les tableaux représentent des collections d'objets dont la taille est dynamique. Les tableaux sont gérés grâce à la classe Array.

Chaque objet de type Array gère une capacité qui est le nombre total d'éléments qu'il est possible d'insérer avant d'agrandir le tableau. Cette capacité a donc une relation avec le nombre d'éléments contenus dans la collection. Lors d'un ajout dans la collection, cette capacité et le nombre d'éléments de la collection déterminent si le tableau doit être agrandi. Si un nombre important d'éléments doit être ajouté, il est possible de forcer l'agrandissement de cette capacité avec la méthode |enlarge|. Son usage évite une perte de temps liée au recalcul de la taille de la collection. 

Exemple :
\lstinputlisting[language=Nit]{./modules/listings/array1_c.nit}

Un constructeur permet de préciser la capacité initiale :
\lstinputlisting[language=Nit]{./modules/listings/array2_c.nit}

\section{Ensembles}
Un ensemble (Set) est une collection qui n'autorise pas la présence de doublons.

L'interface Set définit les méthodes d'une collection qui n'accepte pas de doublons dans ces éléments. Elle hérite de l'interface Collection mais elle ne définit pas de nouvelle méthode. Pour déterminer si un élément est déjà présent dans la collection, la comparaison est basée sur les valeurs des éléments. 

L'interface Set possède deux implémentations concrètes : 

\begin{description}
    \item[ArraySet] Implémentation basée sur les tableaux.
    \item[HashSet] Implémentation basée sur une table de hachage.
\end{description}

Exemple avec l'implémentation ArraySet :
\lstinputlisting[language=Nit]{./modules/listings/set1_c.nit}

\section{Collections gérées sous la forme clé/valeur}
Ce type de collection gère les éléments avec deux entités : une clé et une valeur associée. La clé doit être unique donc il ne peut y avoir de doublons. En revanche la même valeur peut être associée à plusieurs clés différentes.

\subsection{Interface Map}
L'interface Map définit les méthodes d'une collection gérant des ensembles clés => valeur. Elle hérite de l'interface Collection et introduit ou redéfinit les méthodes suivantes :

\begin{tabularx}{\linewidth}{|c|X|}
    \hline
    Méthode & Rôle \\
    \hline
    [](K):E & Retourne l'élément E correspondant à la clé K. \\
    \hline
    []=(K, E) & Définit l'élément E à la clé K. \\
    \hline
    has\_key(K):Bool & Indique si un élément existe à la clé K. \\
    \hline
    recover\_with(Map[K, E]) & Ajoute chaque valeur de la Map passée en paramètre dans la Map courante. En cas de conflit de clé, la valeur de la Map courante est remplacée par celle en paramètre.  \\
    \hline
    remove\_at(K) & Retire l'élément correspondant à la clé K. \\
    \hline
\end{tabularx}

L'interface Map possède une implémentation concrète basée sur une table de hachage, HashMap.

Voici un exemple d'utilisation d'une HashMap :
\lstinputlisting[language=Nit]{./modules/listings/hashmap1_c.nit}

\section{Tri des collections}
Pour trier les collections, Nit propose la classe abstraite AbstractSorter. Elle apporte des fonctionnalités de tri pour les tableaux mais doit être spécialisée pour pouvoir être utilisée. 

\begin{tabularx}{\linewidth}{|c|X|}
    \hline
    Méthode & Rôle \\
    \hline
    compare(E, E):Int & Méthode abstraite de comparaison. \\
    \hline
    sort(Array[E]) & Trie le tableau passé en paramètre. \\
    \hline
\end{tabularx}

La méthode compare doit être redéfinie dans une sous classe afin de pouvoir être utilisée.

Nit propose une implémentation par défaut basée sur les comparables : ComparableSorter.

Voici un exemple de son utilisation :
\lstinputlisting[language=Nit]{./modules/listings/sorter1_c.nit}

