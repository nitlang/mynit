# Parser generated by nitcc
import nitcc_runtime
class MyParser
	super Parser
	redef fun start_state do return state_Start
end
redef class Object
	private fun state_Start: LRStateStart do return once new LRStateStart
	private fun state_listing: LRStatelisting do return once new LRStatelisting
	private fun state_line_43d: LRStateline_43d do return once new LRStateline_43d
	private fun state_line: LRStateline do return once new LRStateline
	private fun state_label_decl: LRStatelabel_decl do return once new LRStatelabel_decl
	private fun state_id: LRStateid do return once new LRStateid
	private fun state_comment: LRStatecomment do return once new LRStatecomment
	private fun state_eol: LRStateeol do return once new LRStateeol
	private fun state_instruction: LRStateinstruction do return once new LRStateinstruction
	private fun state_directive: LRStatedirective do return once new LRStatedirective
	private fun state_tk_byte: LRStatetk_byte do return once new LRStatetk_byte
	private fun state_tk_word: LRStatetk_word do return once new LRStatetk_word
	private fun state_tk_block: LRStatetk_block do return once new LRStatetk_block
	private fun state_tk_ascii: LRStatetk_ascii do return once new LRStatetk_ascii
	private fun state_tk_addrss: LRStatetk_addrss do return once new LRStatetk_addrss
	private fun state_tk_equate: LRStatetk_equate do return once new LRStatetk_equate
	private fun state_tk_burn: LRStatetk_burn do return once new LRStatetk_burn
	private fun state_end_block: LRStateend_block do return once new LRStateend_block
	private fun state_listing_32dEof: LRStatelisting_32dEof do return once new LRStatelisting_32dEof
	private fun state_line_43d_32dlabel_decl: LRStateline_43d_32dlabel_decl do return once new LRStateline_43d_32dlabel_decl
	private fun state_line_43d_32dline: LRStateline_43d_32dline do return once new LRStateline_43d_32dline
	private fun state_line_43d_32dend_block: LRStateline_43d_32dend_block do return once new LRStateline_43d_32dend_block
	private fun state_label_decl_32dcomment: LRStatelabel_decl_32dcomment do return once new LRStatelabel_decl_32dcomment
	private fun state_label_decl_32deol: LRStatelabel_decl_32deol do return once new LRStatelabel_decl_32deol
	private fun state_label_decl_32dinstruction: LRStatelabel_decl_32dinstruction do return once new LRStatelabel_decl_32dinstruction
	private fun state_label_decl_32ddirective: LRStatelabel_decl_32ddirective do return once new LRStatelabel_decl_32ddirective
	private fun state_label_decl_32dend_block: LRStatelabel_decl_32dend_block do return once new LRStatelabel_decl_32dend_block
	private fun state_label_decl_32did: LRStatelabel_decl_32did do return once new LRStatelabel_decl_32did
	private fun state_id_32dcolon: LRStateid_32dcolon do return once new LRStateid_32dcolon
	private fun state_id_32doperand: LRStateid_32doperand do return once new LRStateid_32doperand
	private fun state_id_32dvalue: LRStateid_32dvalue do return once new LRStateid_32dvalue
	private fun state_id_32did: LRStateid_32did do return once new LRStateid_32did
	private fun state_id_32dchar: LRStateid_32dchar do return once new LRStateid_32dchar
	private fun state_id_32dstring: LRStateid_32dstring do return once new LRStateid_32dstring
	private fun state_comment_32deol: LRStatecomment_32deol do return once new LRStatecomment_32deol
	private fun state_instruction_32dcomment: LRStateinstruction_32dcomment do return once new LRStateinstruction_32dcomment
	private fun state_instruction_32deol: LRStateinstruction_32deol do return once new LRStateinstruction_32deol
	private fun state_directive_32dcomment: LRStatedirective_32dcomment do return once new LRStatedirective_32dcomment
	private fun state_directive_32deol: LRStatedirective_32deol do return once new LRStatedirective_32deol
	private fun state_tk_byte_32dvalue: LRStatetk_byte_32dvalue do return once new LRStatetk_byte_32dvalue
	private fun state_tk_word_32dvalue: LRStatetk_word_32dvalue do return once new LRStatetk_word_32dvalue
	private fun state_tk_block_32dvalue: LRStatetk_block_32dvalue do return once new LRStatetk_block_32dvalue
	private fun state_tk_ascii_32dvalue: LRStatetk_ascii_32dvalue do return once new LRStatetk_ascii_32dvalue
	private fun state_tk_addrss_32dvalue: LRStatetk_addrss_32dvalue do return once new LRStatetk_addrss_32dvalue
	private fun state_tk_equate_32dvalue: LRStatetk_equate_32dvalue do return once new LRStatetk_equate_32dvalue
	private fun state_tk_burn_32dvalue: LRStatetk_burn_32dvalue do return once new LRStatetk_burn_32dvalue
	private fun state_line_43d_32dlabel_decl_32dend_block: LRStateline_43d_32dlabel_decl_32dend_block do return once new LRStateline_43d_32dlabel_decl_32dend_block
	private fun state_label_decl_32dcomment_32deol: LRStatelabel_decl_32dcomment_32deol do return once new LRStatelabel_decl_32dcomment_32deol
	private fun state_label_decl_32dinstruction_32dcomment: LRStatelabel_decl_32dinstruction_32dcomment do return once new LRStatelabel_decl_32dinstruction_32dcomment
	private fun state_label_decl_32dinstruction_32deol: LRStatelabel_decl_32dinstruction_32deol do return once new LRStatelabel_decl_32dinstruction_32deol
	private fun state_label_decl_32ddirective_32dcomment: LRStatelabel_decl_32ddirective_32dcomment do return once new LRStatelabel_decl_32ddirective_32dcomment
	private fun state_label_decl_32ddirective_32deol: LRStatelabel_decl_32ddirective_32deol do return once new LRStatelabel_decl_32ddirective_32deol
	private fun state_id_32dvalue_32dcomma: LRStateid_32dvalue_32dcomma do return once new LRStateid_32dvalue_32dcomma
	private fun state_instruction_32dcomment_32deol: LRStateinstruction_32dcomment_32deol do return once new LRStateinstruction_32dcomment_32deol
	private fun state_directive_32dcomment_32deol: LRStatedirective_32dcomment_32deol do return once new LRStatedirective_32dcomment_32deol
	private fun state_label_decl_32dinstruction_32dcomment_32deol: LRStatelabel_decl_32dinstruction_32dcomment_32deol do return once new LRStatelabel_decl_32dinstruction_32dcomment_32deol
	private fun state_label_decl_32ddirective_32dcomment_32deol: LRStatelabel_decl_32ddirective_32dcomment_32deol do return once new LRStatelabel_decl_32ddirective_32dcomment_32deol
	private fun state_id_32dvalue_32dcomma_32did: LRStateid_32dvalue_32dcomma_32did do return once new LRStateid_32dvalue_32dcomma_32did
	private fun goto_Nlisting: Goto_Nlisting do return once new Goto_Nlisting
	private fun goto_Nline: Goto_Nline do return once new Goto_Nline
	private fun goto_Nlabel_decl: Goto_Nlabel_decl do return once new Goto_Nlabel_decl
	private fun goto_Ninstruction: Goto_Ninstruction do return once new Goto_Ninstruction
	private fun goto_Noperand: Goto_Noperand do return once new Goto_Noperand
	private fun goto_Nvalue: Goto_Nvalue do return once new Goto_Nvalue
	private fun goto_Ndirective: Goto_Ndirective do return once new Goto_Ndirective
	private fun goto_Nline_43d: Goto_Nline_43d do return once new Goto_Nline_43d
	private fun goto_N_start: Goto_N_start do return once new Goto_N_start
end
redef class NToken
	# guarded action for state Start
	# 11 shift(s) and 0 reduce(s)
	private fun action_sStart(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state listing
	# 1 shift(s) and 0 reduce(s)
	private fun action_slisting(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state line+
	# 11 shift(s) and 0 reduce(s)
	private fun action_sline_43d(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state label_decl
	# 11 shift(s) and 0 reduce(s)
	private fun action_slabel_decl(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state id
	# 4 shift(s) and 1 reduce(s)
	private fun action_sid(parser: Parser) do
		# REDUCE instruction::instruction_unary=id
		var n0 = parser.pop.as(Nid)
		var p1 = new Ninstruction_unary(n0)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Ninstruction)
	end
	# guarded action for state comment
	# 1 shift(s) and 0 reduce(s)
	private fun action_scomment(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state instruction
	# 2 shift(s) and 0 reduce(s)
	private fun action_sinstruction(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state directive
	# 2 shift(s) and 0 reduce(s)
	private fun action_sdirective(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state tk_byte
	# 3 shift(s) and 0 reduce(s)
	private fun action_stk_byte(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state tk_word
	# 3 shift(s) and 0 reduce(s)
	private fun action_stk_word(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state tk_block
	# 3 shift(s) and 0 reduce(s)
	private fun action_stk_block(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state tk_ascii
	# 3 shift(s) and 0 reduce(s)
	private fun action_stk_ascii(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state tk_addrss
	# 3 shift(s) and 0 reduce(s)
	private fun action_stk_addrss(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state tk_equate
	# 3 shift(s) and 0 reduce(s)
	private fun action_stk_equate(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state tk_burn
	# 3 shift(s) and 0 reduce(s)
	private fun action_stk_burn(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state line+ label_decl
	# 11 shift(s) and 0 reduce(s)
	private fun action_sline_43d_32dlabel_decl(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state label_decl comment
	# 1 shift(s) and 0 reduce(s)
	private fun action_slabel_decl_32dcomment(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state label_decl instruction
	# 2 shift(s) and 0 reduce(s)
	private fun action_slabel_decl_32dinstruction(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state label_decl directive
	# 2 shift(s) and 0 reduce(s)
	private fun action_slabel_decl_32ddirective(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state label_decl id
	# 3 shift(s) and 1 reduce(s)
	private fun action_slabel_decl_32did(parser: Parser) do
		# REDUCE instruction::instruction_unary=id
		var n0 = parser.pop.as(Nid)
		var p1 = new Ninstruction_unary(n0)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Ninstruction)
	end
	# guarded action for state id value
	# 1 shift(s) and 1 reduce(s)
	private fun action_sid_32dvalue(parser: Parser) do
		# REDUCE operand::operand_immediate=value
		var n0 = parser.pop.as(Nvalue)
		var p1 = new Noperand_immediate(n0)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Noperand)
	end
	# guarded action for state instruction comment
	# 1 shift(s) and 0 reduce(s)
	private fun action_sinstruction_32dcomment(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state directive comment
	# 1 shift(s) and 0 reduce(s)
	private fun action_sdirective_32dcomment(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state label_decl instruction comment
	# 1 shift(s) and 0 reduce(s)
	private fun action_slabel_decl_32dinstruction_32dcomment(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state label_decl directive comment
	# 1 shift(s) and 0 reduce(s)
	private fun action_slabel_decl_32ddirective_32dcomment(parser: Parser) do
		parser.parse_error
	end
	# guarded action for state id value comma
	# 1 shift(s) and 0 reduce(s)
	private fun action_sid_32dvalue_32dcomma(parser: Parser) do
		parser.parse_error
	end
end
class NIgnored
	super NToken
	redef fun node_name do return "Ignored"
end
class Nend_block
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_end_block)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_line_43d_32dend_block)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_label_decl_32dend_block)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_line_43d_32dlabel_decl_32dend_block)
	end
	redef fun node_name do return "end_block"
end
class Ncomment
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_comment)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_comment)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_label_decl_32dcomment)
	end
	redef fun action_sinstruction(parser) do
		parser.shift(state_instruction_32dcomment)
	end
	redef fun action_sdirective(parser) do
		parser.shift(state_directive_32dcomment)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_label_decl_32dcomment)
	end
	redef fun action_slabel_decl_32dinstruction(parser) do
		parser.shift(state_label_decl_32dinstruction_32dcomment)
	end
	redef fun action_slabel_decl_32ddirective(parser) do
		parser.shift(state_label_decl_32ddirective_32dcomment)
	end
	redef fun node_name do return "comment"
end
class Neol
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_eol)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_eol)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_label_decl_32deol)
	end
	redef fun action_scomment(parser) do
		parser.shift(state_comment_32deol)
	end
	redef fun action_sinstruction(parser) do
		parser.shift(state_instruction_32deol)
	end
	redef fun action_sdirective(parser) do
		parser.shift(state_directive_32deol)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_label_decl_32deol)
	end
	redef fun action_slabel_decl_32dcomment(parser) do
		parser.shift(state_label_decl_32dcomment_32deol)
	end
	redef fun action_slabel_decl_32dinstruction(parser) do
		parser.shift(state_label_decl_32dinstruction_32deol)
	end
	redef fun action_slabel_decl_32ddirective(parser) do
		parser.shift(state_label_decl_32ddirective_32deol)
	end
	redef fun action_sinstruction_32dcomment(parser) do
		parser.shift(state_instruction_32dcomment_32deol)
	end
	redef fun action_sdirective_32dcomment(parser) do
		parser.shift(state_directive_32dcomment_32deol)
	end
	redef fun action_slabel_decl_32dinstruction_32dcomment(parser) do
		parser.shift(state_label_decl_32dinstruction_32dcomment_32deol)
	end
	redef fun action_slabel_decl_32ddirective_32dcomment(parser) do
		parser.shift(state_label_decl_32ddirective_32dcomment_32deol)
	end
	redef fun node_name do return "eol"
end
class Nid
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_id)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_id)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_label_decl_32did)
	end
	redef fun action_sid(parser) do
		parser.shift(state_id_32did)
	end
	redef fun action_stk_byte(parser) do
		parser.shift(state_id_32did)
	end
	redef fun action_stk_word(parser) do
		parser.shift(state_id_32did)
	end
	redef fun action_stk_block(parser) do
		parser.shift(state_id_32did)
	end
	redef fun action_stk_ascii(parser) do
		parser.shift(state_id_32did)
	end
	redef fun action_stk_addrss(parser) do
		parser.shift(state_id_32did)
	end
	redef fun action_stk_equate(parser) do
		parser.shift(state_id_32did)
	end
	redef fun action_stk_burn(parser) do
		parser.shift(state_id_32did)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_label_decl_32did)
	end
	redef fun action_slabel_decl_32did(parser) do
		parser.shift(state_id_32did)
	end
	redef fun action_sid_32dvalue_32dcomma(parser) do
		parser.shift(state_id_32dvalue_32dcomma_32did)
	end
	redef fun node_name do return "id"
end
class Ncolon
	super NToken
	redef fun action_sid(parser) do
		parser.shift(state_id_32dcolon)
	end
	redef fun node_name do return "colon"
end
class Ncomma
	super NToken
	redef fun action_sid_32dvalue(parser) do
		parser.shift(state_id_32dvalue_32dcomma)
	end
	redef fun node_name do return "comma"
end
class Nchar
	super NToken
	redef fun action_sid(parser) do
		parser.shift(state_id_32dchar)
	end
	redef fun action_stk_byte(parser) do
		parser.shift(state_id_32dchar)
	end
	redef fun action_stk_word(parser) do
		parser.shift(state_id_32dchar)
	end
	redef fun action_stk_block(parser) do
		parser.shift(state_id_32dchar)
	end
	redef fun action_stk_ascii(parser) do
		parser.shift(state_id_32dchar)
	end
	redef fun action_stk_addrss(parser) do
		parser.shift(state_id_32dchar)
	end
	redef fun action_stk_equate(parser) do
		parser.shift(state_id_32dchar)
	end
	redef fun action_stk_burn(parser) do
		parser.shift(state_id_32dchar)
	end
	redef fun action_slabel_decl_32did(parser) do
		parser.shift(state_id_32dchar)
	end
	redef fun node_name do return "char"
end
class Nstring
	super NToken
	redef fun action_sid(parser) do
		parser.shift(state_id_32dstring)
	end
	redef fun action_stk_byte(parser) do
		parser.shift(state_id_32dstring)
	end
	redef fun action_stk_word(parser) do
		parser.shift(state_id_32dstring)
	end
	redef fun action_stk_block(parser) do
		parser.shift(state_id_32dstring)
	end
	redef fun action_stk_ascii(parser) do
		parser.shift(state_id_32dstring)
	end
	redef fun action_stk_addrss(parser) do
		parser.shift(state_id_32dstring)
	end
	redef fun action_stk_equate(parser) do
		parser.shift(state_id_32dstring)
	end
	redef fun action_stk_burn(parser) do
		parser.shift(state_id_32dstring)
	end
	redef fun action_slabel_decl_32did(parser) do
		parser.shift(state_id_32dstring)
	end
	redef fun node_name do return "string"
end
class Ntk_byte
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_tk_byte)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_tk_byte)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_tk_byte)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_tk_byte)
	end
	redef fun node_name do return "tk_byte"
end
class Ntk_word
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_tk_word)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_tk_word)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_tk_word)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_tk_word)
	end
	redef fun node_name do return "tk_word"
end
class Ntk_block
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_tk_block)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_tk_block)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_tk_block)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_tk_block)
	end
	redef fun node_name do return "tk_block"
end
class Ntk_ascii
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_tk_ascii)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_tk_ascii)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_tk_ascii)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_tk_ascii)
	end
	redef fun node_name do return "tk_ascii"
end
class Ntk_addrss
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_tk_addrss)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_tk_addrss)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_tk_addrss)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_tk_addrss)
	end
	redef fun node_name do return "tk_addrss"
end
class Ntk_equate
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_tk_equate)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_tk_equate)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_tk_equate)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_tk_equate)
	end
	redef fun node_name do return "tk_equate"
end
class Ntk_burn
	super NToken
	redef fun action_sStart(parser) do
		parser.shift(state_tk_burn)
	end
	redef fun action_sline_43d(parser) do
		parser.shift(state_tk_burn)
	end
	redef fun action_slabel_decl(parser) do
		parser.shift(state_tk_burn)
	end
	redef fun action_sline_43d_32dlabel_decl(parser) do
		parser.shift(state_tk_burn)
	end
	redef fun node_name do return "tk_burn"
end
redef class NEof
	super NToken
	redef fun action_slisting(parser) do
		parser.shift(state_listing_32dEof)
	end
	redef fun node_name do return "Eof"
end
redef class LRGoto
	private fun goto_sStart(parser: Parser) do abort
	private fun goto_sline_43d(parser: Parser) do abort
	private fun goto_slabel_decl(parser: Parser) do abort
	private fun goto_sid(parser: Parser) do abort
	private fun goto_sline_43d_32dlabel_decl(parser: Parser) do abort
	private fun goto_slabel_decl_32did(parser: Parser) do abort
end
class Goto_Nlisting
	super LRGoto
	redef fun goto_sStart(parser) do
		parser.push(state_listing)
	end
end
class Goto_Nline
	super LRGoto
	redef fun goto_sStart(parser) do
		parser.push(state_line)
	end
	redef fun goto_sline_43d(parser) do
		parser.push(state_line_43d_32dline)
	end
end
class Goto_Nlabel_decl
	super LRGoto
	redef fun goto_sStart(parser) do
		parser.push(state_label_decl)
	end
	redef fun goto_sline_43d(parser) do
		parser.push(state_line_43d_32dlabel_decl)
	end
end
class Goto_Ninstruction
	super LRGoto
	redef fun goto_sStart(parser) do
		parser.push(state_instruction)
	end
	redef fun goto_sline_43d(parser) do
		parser.push(state_instruction)
	end
	redef fun goto_slabel_decl(parser) do
		parser.push(state_label_decl_32dinstruction)
	end
	redef fun goto_sline_43d_32dlabel_decl(parser) do
		parser.push(state_label_decl_32dinstruction)
	end
end
class Goto_Noperand
	super LRGoto
	redef fun goto_sid(parser) do
		parser.push(state_id_32doperand)
	end
	redef fun goto_slabel_decl_32did(parser) do
		parser.push(state_id_32doperand)
	end
end
class Goto_Nvalue
	super LRGoto
	redef fun goto_sid(parser) do
		parser.push(state_id_32dvalue)
	end
	redef fun goto_slabel_decl_32did(parser) do
		parser.push(state_id_32dvalue)
	end
end
class Goto_Ndirective
	super LRGoto
	redef fun goto_sStart(parser) do
		parser.push(state_directive)
	end
	redef fun goto_sline_43d(parser) do
		parser.push(state_directive)
	end
	redef fun goto_slabel_decl(parser) do
		parser.push(state_label_decl_32ddirective)
	end
	redef fun goto_sline_43d_32dlabel_decl(parser) do
		parser.push(state_label_decl_32ddirective)
	end
end
class Goto_Nline_43d
	super LRGoto
	redef fun goto_sStart(parser) do
		parser.push(state_line_43d)
	end
end
class Goto_N_start
	super LRGoto
end
class Nlisting
	super NProd
	redef fun node_name do return "listing"
	var n_lines: nullable Nodes[Nline]
	var n_label_decl: nullable Nlabel_decl
	var n_end_block: Nend_block
	init(n_lines: nullable Nodes[Nline], n_label_decl: nullable Nlabel_decl, n_end_block: Nend_block) do
		self.n_lines = n_lines
		self.n_label_decl = n_label_decl
		self.n_end_block = n_end_block
	end
	redef fun number_of_children do return 3
	redef fun child(i) do
		if i == 0 then return n_lines
		if i == 1 then return n_label_decl
		if i == 2 then return n_end_block
		abort
	end
end
class Nline
	super NProd
	redef fun node_name do return "line"
end
class Nline_empty
	super Nline
	redef fun node_name do return "line_empty"
	var n_label_decl: nullable Nlabel_decl
	var n_comment: nullable Ncomment
	var n_eol: Neol
	init(n_label_decl: nullable Nlabel_decl, n_comment: nullable Ncomment, n_eol: Neol) do
		self.n_label_decl = n_label_decl
		self.n_comment = n_comment
		self.n_eol = n_eol
	end
	redef fun number_of_children do return 3
	redef fun child(i) do
		if i == 0 then return n_label_decl
		if i == 1 then return n_comment
		if i == 2 then return n_eol
		abort
	end
end
class Nline_instruction
	super Nline
	redef fun node_name do return "line_instruction"
	var n_label_decl: nullable Nlabel_decl
	var n_instruction: Ninstruction
	var n_comment: nullable Ncomment
	var n_eol: Neol
	init(n_label_decl: nullable Nlabel_decl, n_instruction: Ninstruction, n_comment: nullable Ncomment, n_eol: Neol) do
		self.n_label_decl = n_label_decl
		self.n_instruction = n_instruction
		self.n_comment = n_comment
		self.n_eol = n_eol
	end
	redef fun number_of_children do return 4
	redef fun child(i) do
		if i == 0 then return n_label_decl
		if i == 1 then return n_instruction
		if i == 2 then return n_comment
		if i == 3 then return n_eol
		abort
	end
end
class Nline_directive
	super Nline
	redef fun node_name do return "line_directive"
	var n_label_decl: nullable Nlabel_decl
	var n_directive: Ndirective
	var n_comment: nullable Ncomment
	var n_eol: Neol
	init(n_label_decl: nullable Nlabel_decl, n_directive: Ndirective, n_comment: nullable Ncomment, n_eol: Neol) do
		self.n_label_decl = n_label_decl
		self.n_directive = n_directive
		self.n_comment = n_comment
		self.n_eol = n_eol
	end
	redef fun number_of_children do return 4
	redef fun child(i) do
		if i == 0 then return n_label_decl
		if i == 1 then return n_directive
		if i == 2 then return n_comment
		if i == 3 then return n_eol
		abort
	end
end
class Nlabel_decl
	super NProd
	redef fun node_name do return "label_decl"
	var n_id: Nid
	var n_colon: Ncolon
	init(n_id: Nid, n_colon: Ncolon) do
		self.n_id = n_id
		self.n_colon = n_colon
	end
	redef fun number_of_children do return 2
	redef fun child(i) do
		if i == 0 then return n_id
		if i == 1 then return n_colon
		abort
	end
end
class Ninstruction
	super NProd
	redef fun node_name do return "instruction"
end
class Ninstruction_unary
	super Ninstruction
	redef fun node_name do return "instruction_unary"
	var n_id: Nid
	init(n_id: Nid) do
		self.n_id = n_id
	end
	redef fun number_of_children do return 1
	redef fun child(i) do
		if i == 0 then return n_id
		abort
	end
end
class Ninstruction_binary
	super Ninstruction
	redef fun node_name do return "instruction_binary"
	var n_id: Nid
	var n_operand: Noperand
	init(n_id: Nid, n_operand: Noperand) do
		self.n_id = n_id
		self.n_operand = n_operand
	end
	redef fun number_of_children do return 2
	redef fun child(i) do
		if i == 0 then return n_id
		if i == 1 then return n_operand
		abort
	end
end
class Noperand
	super NProd
	redef fun node_name do return "operand"
end
class Noperand_immediate
	super Noperand
	redef fun node_name do return "operand_immediate"
	var n_value: Nvalue
	init(n_value: Nvalue) do
		self.n_value = n_value
	end
	redef fun number_of_children do return 1
	redef fun child(i) do
		if i == 0 then return n_value
		abort
	end
end
class Noperand_any
	super Noperand
	redef fun node_name do return "operand_any"
	var n_value: Nvalue
	var n_comma: Ncomma
	var n_id: Nid
	init(n_value: Nvalue, n_comma: Ncomma, n_id: Nid) do
		self.n_value = n_value
		self.n_comma = n_comma
		self.n_id = n_id
	end
	redef fun number_of_children do return 3
	redef fun child(i) do
		if i == 0 then return n_value
		if i == 1 then return n_comma
		if i == 2 then return n_id
		abort
	end
end
class Nvalue
	super NProd
	redef fun node_name do return "value"
end
class Nvalue_label
	super Nvalue
	redef fun node_name do return "value_label"
	var n_id: Nid
	init(n_id: Nid) do
		self.n_id = n_id
	end
	redef fun number_of_children do return 1
	redef fun child(i) do
		if i == 0 then return n_id
		abort
	end
end
class Nvalue_char
	super Nvalue
	redef fun node_name do return "value_char"
	var n_char: Nchar
	init(n_char: Nchar) do
		self.n_char = n_char
	end
	redef fun number_of_children do return 1
	redef fun child(i) do
		if i == 0 then return n_char
		abort
	end
end
class Nvalue_string
	super Nvalue
	redef fun node_name do return "value_string"
	var n_string: Nstring
	init(n_string: Nstring) do
		self.n_string = n_string
	end
	redef fun number_of_children do return 1
	redef fun child(i) do
		if i == 0 then return n_string
		abort
	end
end
class Ndirective
	super NProd
	redef fun node_name do return "directive"
end
class Ndirective_byte
	super Ndirective
	redef fun node_name do return "directive_byte"
	var n_tk_byte: Ntk_byte
	var n_value: Nvalue
	init(n_tk_byte: Ntk_byte, n_value: Nvalue) do
		self.n_tk_byte = n_tk_byte
		self.n_value = n_value
	end
	redef fun number_of_children do return 2
	redef fun child(i) do
		if i == 0 then return n_tk_byte
		if i == 1 then return n_value
		abort
	end
end
class Ndirective_word
	super Ndirective
	redef fun node_name do return "directive_word"
	var n_tk_word: Ntk_word
	var n_value: Nvalue
	init(n_tk_word: Ntk_word, n_value: Nvalue) do
		self.n_tk_word = n_tk_word
		self.n_value = n_value
	end
	redef fun number_of_children do return 2
	redef fun child(i) do
		if i == 0 then return n_tk_word
		if i == 1 then return n_value
		abort
	end
end
class Ndirective_block
	super Ndirective
	redef fun node_name do return "directive_block"
	var n_tk_block: Ntk_block
	var n_value: Nvalue
	init(n_tk_block: Ntk_block, n_value: Nvalue) do
		self.n_tk_block = n_tk_block
		self.n_value = n_value
	end
	redef fun number_of_children do return 2
	redef fun child(i) do
		if i == 0 then return n_tk_block
		if i == 1 then return n_value
		abort
	end
end
class Ndirective_ascii
	super Ndirective
	redef fun node_name do return "directive_ascii"
	var n_tk_ascii: Ntk_ascii
	var n_value: Nvalue
	init(n_tk_ascii: Ntk_ascii, n_value: Nvalue) do
		self.n_tk_ascii = n_tk_ascii
		self.n_value = n_value
	end
	redef fun number_of_children do return 2
	redef fun child(i) do
		if i == 0 then return n_tk_ascii
		if i == 1 then return n_value
		abort
	end
end
class Ndirective_addrss
	super Ndirective
	redef fun node_name do return "directive_addrss"
	var n_tk_addrss: Ntk_addrss
	var n_value: Nvalue
	init(n_tk_addrss: Ntk_addrss, n_value: Nvalue) do
		self.n_tk_addrss = n_tk_addrss
		self.n_value = n_value
	end
	redef fun number_of_children do return 2
	redef fun child(i) do
		if i == 0 then return n_tk_addrss
		if i == 1 then return n_value
		abort
	end
end
class Ndirective_equate
	super Ndirective
	redef fun node_name do return "directive_equate"
	var n_tk_equate: Ntk_equate
	var n_value: Nvalue
	init(n_tk_equate: Ntk_equate, n_value: Nvalue) do
		self.n_tk_equate = n_tk_equate
		self.n_value = n_value
	end
	redef fun number_of_children do return 2
	redef fun child(i) do
		if i == 0 then return n_tk_equate
		if i == 1 then return n_value
		abort
	end
end
class Ndirective_burn
	super Ndirective
	redef fun node_name do return "directive_burn"
	var n_tk_burn: Ntk_burn
	var n_value: Nvalue
	init(n_tk_burn: Ntk_burn, n_value: Nvalue) do
		self.n_tk_burn = n_tk_burn
		self.n_value = n_value
	end
	redef fun number_of_children do return 2
	redef fun child(i) do
		if i == 0 then return n_tk_burn
		if i == 1 then return n_value
		abort
	end
end
class N_start
	super NProd
	redef fun node_name do return "_start"
end
class NStart
	super N_start
	redef fun node_name do return "Start"
	var n_0: Nlisting
	var n_1: NEof
	init(n_0: Nlisting, n_1: NEof) do
		self.n_0 = n_0
		self.n_1 = n_1
	end
	redef fun number_of_children do return 2
	redef fun child(i) do
		if i == 0 then return n_0
		if i == 1 then return n_1
		abort
	end
end
# State Start
private class LRStateStart
	super LRState
	redef fun to_s do return "Start"
	redef fun error_msg do return "listing, line+, line, label_decl, instruction, directive"
	redef fun action(parser) do
		parser.peek_token.action_sStart(parser)
	end
	redef fun goto(parser, goto) do
		goto.goto_sStart(parser)
	end
end
# State listing
private class LRStatelisting
	super LRState
	redef fun to_s do return "listing"
	redef fun error_msg do return "Eof"
	redef fun action(parser) do
		parser.peek_token.action_slisting(parser)
	end
end
# State line+
private class LRStateline_43d
	super LRState
	redef fun to_s do return "line+"
	redef fun error_msg do return "label_decl, line, instruction, directive"
	redef fun action(parser) do
		parser.peek_token.action_sline_43d(parser)
	end
	redef fun goto(parser, goto) do
		goto.goto_sline_43d(parser)
	end
end
# State line
private class LRStateline
	super LRState
	redef fun to_s do return "line"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line+::line+_one=line
		var n0 = parser.pop.as(Nline)
		var prod = new Nodes[Nline]
		prod.items.add(n0)
		parser.node_stack.push prod
		parser.goto(goto_Nline_43d)
	end
end
# State label_decl
private class LRStatelabel_decl
	super LRState
	redef fun to_s do return "label_decl"
	redef fun error_msg do return "instruction, directive"
	redef fun action(parser) do
		parser.peek_token.action_slabel_decl(parser)
	end
	redef fun goto(parser, goto) do
		goto.goto_slabel_decl(parser)
	end
end
# State id
private class LRStateid
	super LRState
	redef fun to_s do return "id"
	redef fun error_msg do return "operand, value"
	redef fun action(parser) do
		parser.peek_token.action_sid(parser)
	end
	redef fun goto(parser, goto) do
		goto.goto_sid(parser)
	end
end
# State comment
private class LRStatecomment
	super LRState
	redef fun to_s do return "comment"
	redef fun error_msg do return "eol"
	redef fun action(parser) do
		parser.peek_token.action_scomment(parser)
	end
end
# State eol
private class LRStateeol
	super LRState
	redef fun to_s do return "eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_empty_3=eol
		var n0 = parser.pop.as(Neol)
		var p1 = new Nline_empty(null, null, n0)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State instruction
private class LRStateinstruction
	super LRState
	redef fun to_s do return "instruction"
	redef fun error_msg do return "comment, eol"
	redef fun action(parser) do
		parser.peek_token.action_sinstruction(parser)
	end
end
# State directive
private class LRStatedirective
	super LRState
	redef fun to_s do return "directive"
	redef fun error_msg do return "comment, eol"
	redef fun action(parser) do
		parser.peek_token.action_sdirective(parser)
	end
end
# State tk_byte
private class LRStatetk_byte
	super LRState
	redef fun to_s do return "tk_byte"
	redef fun error_msg do return "value"
	redef fun action(parser) do
		parser.peek_token.action_stk_byte(parser)
	end
	redef fun goto(parser, goto) do
		parser.push(state_tk_byte_32dvalue)
	end
end
# State tk_word
private class LRStatetk_word
	super LRState
	redef fun to_s do return "tk_word"
	redef fun error_msg do return "value"
	redef fun action(parser) do
		parser.peek_token.action_stk_word(parser)
	end
	redef fun goto(parser, goto) do
		parser.push(state_tk_word_32dvalue)
	end
end
# State tk_block
private class LRStatetk_block
	super LRState
	redef fun to_s do return "tk_block"
	redef fun error_msg do return "value"
	redef fun action(parser) do
		parser.peek_token.action_stk_block(parser)
	end
	redef fun goto(parser, goto) do
		parser.push(state_tk_block_32dvalue)
	end
end
# State tk_ascii
private class LRStatetk_ascii
	super LRState
	redef fun to_s do return "tk_ascii"
	redef fun error_msg do return "value"
	redef fun action(parser) do
		parser.peek_token.action_stk_ascii(parser)
	end
	redef fun goto(parser, goto) do
		parser.push(state_tk_ascii_32dvalue)
	end
end
# State tk_addrss
private class LRStatetk_addrss
	super LRState
	redef fun to_s do return "tk_addrss"
	redef fun error_msg do return "value"
	redef fun action(parser) do
		parser.peek_token.action_stk_addrss(parser)
	end
	redef fun goto(parser, goto) do
		parser.push(state_tk_addrss_32dvalue)
	end
end
# State tk_equate
private class LRStatetk_equate
	super LRState
	redef fun to_s do return "tk_equate"
	redef fun error_msg do return "value"
	redef fun action(parser) do
		parser.peek_token.action_stk_equate(parser)
	end
	redef fun goto(parser, goto) do
		parser.push(state_tk_equate_32dvalue)
	end
end
# State tk_burn
private class LRStatetk_burn
	super LRState
	redef fun to_s do return "tk_burn"
	redef fun error_msg do return "value"
	redef fun action(parser) do
		parser.peek_token.action_stk_burn(parser)
	end
	redef fun goto(parser, goto) do
		parser.push(state_tk_burn_32dvalue)
	end
end
# State end_block
private class LRStateend_block
	super LRState
	redef fun to_s do return "end_block"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE listing::listing_3=end_block
		var n0 = parser.pop.as(Nend_block)
		var p1 = new Nlisting(null, null, n0)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nlisting)
	end
end
# State listing Eof
private class LRStatelisting_32dEof
	super LRState
	redef fun to_s do return "listing Eof"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE _start::Start=listing Eof
		var n1 = parser.pop.as(NEof)
		var n0 = parser.pop.as(Nlisting)
		var p1 = new NStart(n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.stop = true
	end
end
# State line+ label_decl
private class LRStateline_43d_32dlabel_decl
	super LRState
	redef fun to_s do return "line+ label_decl"
	redef fun error_msg do return "instruction, directive"
	redef fun action(parser) do
		parser.peek_token.action_sline_43d_32dlabel_decl(parser)
	end
	redef fun goto(parser, goto) do
		goto.goto_sline_43d_32dlabel_decl(parser)
	end
end
# State line+ line
private class LRStateline_43d_32dline
	super LRState
	redef fun to_s do return "line+ line"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line+::line+_more=line+ line
		var n1 = parser.pop.as(Nline)
		var n0 = parser.pop.as(Nodes[Nline])
		var prod = n0
		n0.items.add(n1)
		parser.node_stack.push prod
		parser.goto(goto_Nline_43d)
	end
end
# State line+ end_block
private class LRStateline_43d_32dend_block
	super LRState
	redef fun to_s do return "line+ end_block"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE listing::listing_2=line+ end_block
		var n1 = parser.pop.as(Nend_block)
		var n0 = parser.pop.as(Nodes[Nline])
		var p1 = new Nlisting(n0, null, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nlisting)
	end
end
# State label_decl comment
private class LRStatelabel_decl_32dcomment
	super LRState
	redef fun to_s do return "label_decl comment"
	redef fun error_msg do return "eol"
	redef fun action(parser) do
		parser.peek_token.action_slabel_decl_32dcomment(parser)
	end
end
# State label_decl eol
private class LRStatelabel_decl_32deol
	super LRState
	redef fun to_s do return "label_decl eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_empty_2=label_decl eol
		var n1 = parser.pop.as(Neol)
		var n0 = parser.pop.as(Nlabel_decl)
		var p1 = new Nline_empty(n0, null, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State label_decl instruction
private class LRStatelabel_decl_32dinstruction
	super LRState
	redef fun to_s do return "label_decl instruction"
	redef fun error_msg do return "comment, eol"
	redef fun action(parser) do
		parser.peek_token.action_slabel_decl_32dinstruction(parser)
	end
end
# State label_decl directive
private class LRStatelabel_decl_32ddirective
	super LRState
	redef fun to_s do return "label_decl directive"
	redef fun error_msg do return "comment, eol"
	redef fun action(parser) do
		parser.peek_token.action_slabel_decl_32ddirective(parser)
	end
end
# State label_decl end_block
private class LRStatelabel_decl_32dend_block
	super LRState
	redef fun to_s do return "label_decl end_block"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE listing::listing_1=label_decl end_block
		var n1 = parser.pop.as(Nend_block)
		var n0 = parser.pop.as(Nlabel_decl)
		var p1 = new Nlisting(null, n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nlisting)
	end
end
# State label_decl id
private class LRStatelabel_decl_32did
	super LRState
	redef fun to_s do return "label_decl id"
	redef fun error_msg do return "operand, value"
	redef fun action(parser) do
		parser.peek_token.action_slabel_decl_32did(parser)
	end
	redef fun goto(parser, goto) do
		goto.goto_slabel_decl_32did(parser)
	end
end
# State id colon
private class LRStateid_32dcolon
	super LRState
	redef fun to_s do return "id colon"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE label_decl::label_decl=id colon
		var n1 = parser.pop.as(Ncolon)
		var n0 = parser.pop.as(Nid)
		var p1 = new Nlabel_decl(n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nlabel_decl)
	end
end
# State id operand
private class LRStateid_32doperand
	super LRState
	redef fun to_s do return "id operand"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE instruction::instruction_binary=id operand
		var n1 = parser.pop.as(Noperand)
		var n0 = parser.pop.as(Nid)
		var p1 = new Ninstruction_binary(n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Ninstruction)
	end
end
# State id value
private class LRStateid_32dvalue
	super LRState
	redef fun to_s do return "id value"
	redef fun error_msg do return "comma"
	redef fun action(parser) do
		parser.peek_token.action_sid_32dvalue(parser)
	end
end
# State id id
private class LRStateid_32did
	super LRState
	redef fun to_s do return "id id"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE value::value_label=id
		var n0 = parser.pop.as(Nid)
		var p1 = new Nvalue_label(n0)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nvalue)
	end
end
# State id char
private class LRStateid_32dchar
	super LRState
	redef fun to_s do return "id char"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE value::value_char=char
		var n0 = parser.pop.as(Nchar)
		var p1 = new Nvalue_char(n0)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nvalue)
	end
end
# State id string
private class LRStateid_32dstring
	super LRState
	redef fun to_s do return "id string"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE value::value_string=string
		var n0 = parser.pop.as(Nstring)
		var p1 = new Nvalue_string(n0)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nvalue)
	end
end
# State comment eol
private class LRStatecomment_32deol
	super LRState
	redef fun to_s do return "comment eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_empty_1=comment eol
		var n1 = parser.pop.as(Neol)
		var n0 = parser.pop.as(Ncomment)
		var p1 = new Nline_empty(null, n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State instruction comment
private class LRStateinstruction_32dcomment
	super LRState
	redef fun to_s do return "instruction comment"
	redef fun error_msg do return "eol"
	redef fun action(parser) do
		parser.peek_token.action_sinstruction_32dcomment(parser)
	end
end
# State instruction eol
private class LRStateinstruction_32deol
	super LRState
	redef fun to_s do return "instruction eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_instruction_3=instruction eol
		var n1 = parser.pop.as(Neol)
		var n0 = parser.pop.as(Ninstruction)
		var p1 = new Nline_instruction(null, n0, null, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State directive comment
private class LRStatedirective_32dcomment
	super LRState
	redef fun to_s do return "directive comment"
	redef fun error_msg do return "eol"
	redef fun action(parser) do
		parser.peek_token.action_sdirective_32dcomment(parser)
	end
end
# State directive eol
private class LRStatedirective_32deol
	super LRState
	redef fun to_s do return "directive eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_directive_3=directive eol
		var n1 = parser.pop.as(Neol)
		var n0 = parser.pop.as(Ndirective)
		var p1 = new Nline_directive(null, n0, null, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State tk_byte value
private class LRStatetk_byte_32dvalue
	super LRState
	redef fun to_s do return "tk_byte value"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE directive::directive_byte=tk_byte value
		var n1 = parser.pop.as(Nvalue)
		var n0 = parser.pop.as(Ntk_byte)
		var p1 = new Ndirective_byte(n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Ndirective)
	end
end
# State tk_word value
private class LRStatetk_word_32dvalue
	super LRState
	redef fun to_s do return "tk_word value"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE directive::directive_word=tk_word value
		var n1 = parser.pop.as(Nvalue)
		var n0 = parser.pop.as(Ntk_word)
		var p1 = new Ndirective_word(n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Ndirective)
	end
end
# State tk_block value
private class LRStatetk_block_32dvalue
	super LRState
	redef fun to_s do return "tk_block value"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE directive::directive_block=tk_block value
		var n1 = parser.pop.as(Nvalue)
		var n0 = parser.pop.as(Ntk_block)
		var p1 = new Ndirective_block(n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Ndirective)
	end
end
# State tk_ascii value
private class LRStatetk_ascii_32dvalue
	super LRState
	redef fun to_s do return "tk_ascii value"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE directive::directive_ascii=tk_ascii value
		var n1 = parser.pop.as(Nvalue)
		var n0 = parser.pop.as(Ntk_ascii)
		var p1 = new Ndirective_ascii(n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Ndirective)
	end
end
# State tk_addrss value
private class LRStatetk_addrss_32dvalue
	super LRState
	redef fun to_s do return "tk_addrss value"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE directive::directive_addrss=tk_addrss value
		var n1 = parser.pop.as(Nvalue)
		var n0 = parser.pop.as(Ntk_addrss)
		var p1 = new Ndirective_addrss(n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Ndirective)
	end
end
# State tk_equate value
private class LRStatetk_equate_32dvalue
	super LRState
	redef fun to_s do return "tk_equate value"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE directive::directive_equate=tk_equate value
		var n1 = parser.pop.as(Nvalue)
		var n0 = parser.pop.as(Ntk_equate)
		var p1 = new Ndirective_equate(n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Ndirective)
	end
end
# State tk_burn value
private class LRStatetk_burn_32dvalue
	super LRState
	redef fun to_s do return "tk_burn value"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE directive::directive_burn=tk_burn value
		var n1 = parser.pop.as(Nvalue)
		var n0 = parser.pop.as(Ntk_burn)
		var p1 = new Ndirective_burn(n0, n1)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Ndirective)
	end
end
# State line+ label_decl end_block
private class LRStateline_43d_32dlabel_decl_32dend_block
	super LRState
	redef fun to_s do return "line+ label_decl end_block"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE listing::listing_0=line+ label_decl end_block
		var n2 = parser.pop.as(Nend_block)
		var n1 = parser.pop.as(Nlabel_decl)
		var n0 = parser.pop.as(Nodes[Nline])
		var p1 = new Nlisting(n0, n1, n2)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nlisting)
	end
end
# State label_decl comment eol
private class LRStatelabel_decl_32dcomment_32deol
	super LRState
	redef fun to_s do return "label_decl comment eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_empty_0=label_decl comment eol
		var n2 = parser.pop.as(Neol)
		var n1 = parser.pop.as(Ncomment)
		var n0 = parser.pop.as(Nlabel_decl)
		var p1 = new Nline_empty(n0, n1, n2)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State label_decl instruction comment
private class LRStatelabel_decl_32dinstruction_32dcomment
	super LRState
	redef fun to_s do return "label_decl instruction comment"
	redef fun error_msg do return "eol"
	redef fun action(parser) do
		parser.peek_token.action_slabel_decl_32dinstruction_32dcomment(parser)
	end
end
# State label_decl instruction eol
private class LRStatelabel_decl_32dinstruction_32deol
	super LRState
	redef fun to_s do return "label_decl instruction eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_instruction_2=label_decl instruction eol
		var n2 = parser.pop.as(Neol)
		var n1 = parser.pop.as(Ninstruction)
		var n0 = parser.pop.as(Nlabel_decl)
		var p1 = new Nline_instruction(n0, n1, null, n2)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State label_decl directive comment
private class LRStatelabel_decl_32ddirective_32dcomment
	super LRState
	redef fun to_s do return "label_decl directive comment"
	redef fun error_msg do return "eol"
	redef fun action(parser) do
		parser.peek_token.action_slabel_decl_32ddirective_32dcomment(parser)
	end
end
# State label_decl directive eol
private class LRStatelabel_decl_32ddirective_32deol
	super LRState
	redef fun to_s do return "label_decl directive eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_directive_2=label_decl directive eol
		var n2 = parser.pop.as(Neol)
		var n1 = parser.pop.as(Ndirective)
		var n0 = parser.pop.as(Nlabel_decl)
		var p1 = new Nline_directive(n0, n1, null, n2)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State id value comma
private class LRStateid_32dvalue_32dcomma
	super LRState
	redef fun to_s do return "id value comma"
	redef fun error_msg do return "id"
	redef fun action(parser) do
		parser.peek_token.action_sid_32dvalue_32dcomma(parser)
	end
end
# State instruction comment eol
private class LRStateinstruction_32dcomment_32deol
	super LRState
	redef fun to_s do return "instruction comment eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_instruction_1=instruction comment eol
		var n2 = parser.pop.as(Neol)
		var n1 = parser.pop.as(Ncomment)
		var n0 = parser.pop.as(Ninstruction)
		var p1 = new Nline_instruction(null, n0, n1, n2)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State directive comment eol
private class LRStatedirective_32dcomment_32deol
	super LRState
	redef fun to_s do return "directive comment eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_directive_1=directive comment eol
		var n2 = parser.pop.as(Neol)
		var n1 = parser.pop.as(Ncomment)
		var n0 = parser.pop.as(Ndirective)
		var p1 = new Nline_directive(null, n0, n1, n2)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State label_decl instruction comment eol
private class LRStatelabel_decl_32dinstruction_32dcomment_32deol
	super LRState
	redef fun to_s do return "label_decl instruction comment eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_instruction_0=label_decl instruction comment eol
		var n3 = parser.pop.as(Neol)
		var n2 = parser.pop.as(Ncomment)
		var n1 = parser.pop.as(Ninstruction)
		var n0 = parser.pop.as(Nlabel_decl)
		var p1 = new Nline_instruction(n0, n1, n2, n3)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State label_decl directive comment eol
private class LRStatelabel_decl_32ddirective_32dcomment_32deol
	super LRState
	redef fun to_s do return "label_decl directive comment eol"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE line::line_directive_0=label_decl directive comment eol
		var n3 = parser.pop.as(Neol)
		var n2 = parser.pop.as(Ncomment)
		var n1 = parser.pop.as(Ndirective)
		var n0 = parser.pop.as(Nlabel_decl)
		var p1 = new Nline_directive(n0, n1, n2, n3)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Nline)
	end
end
# State id value comma id
private class LRStateid_32dvalue_32dcomma_32did
	super LRState
	redef fun to_s do return "id value comma id"
	redef fun error_msg do return ""
	redef fun action(parser) do
		# REDUCE operand::operand_any=value comma id
		var n2 = parser.pop.as(Nid)
		var n1 = parser.pop.as(Ncomma)
		var n0 = parser.pop.as(Nvalue)
		var p1 = new Noperand_any(n0, n1, n2)
		var prod = p1
		parser.node_stack.push prod
		parser.goto(goto_Noperand)
	end
end
