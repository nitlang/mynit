\part{Syntaxe et éléments de base de Nit}

\chapter{Syntaxe}

\section{Nit est sensible à la casse}
Nit est sensible à la casse :
\lstinputlisting[language=Nit]{./syntaxe/listings/var_c.nit}
Ici |ma_var| et |ma_VAR| sont deux variables différentes.

\section{Retours chariots}
Avec Nit, les retours chariots ont du sens !

Exemple \og One Liner \fg :
\lstinputlisting[language=Nit,linerange=1-1]{./syntaxe/listings/chariot_s.nit}
Exemple \og Bloc \fg :
\lstinputlisting[language=Nit,linerange=2-4]{./syntaxe/listings/chariot_s.nit}

Notez que l'indentation est ignorée du compilateur mais elle permet une meilleure compréhension du code par le programmeur, il est donc conseillé de bien indenter son code !

\pagebreak

\section{Identificateurs}

Chaque objet, classe, module ou variable est associé à un nom : l'\textbf{identificateur} qui peut se composer de tous les caractères alphanumériques et du caractère de soulignement (\_). Le premier caractère doit être une lettre ou le caractère de soulignement. 

Attention : Le compilateur lèvera une exception si une variable commence par une majuscule.

Un identificateur ne peut pas appartenir à la liste des mots clés réservés du langage Nit :
\begin{multicols}{4}
  \begin{itemize}
      \item |abort|
      \item |abstract|
      \item |and|
      \item |as|
      \item |assert|
      \item |break|
      \item |class|
      \item |continue|
      \item |do|
      \item |else|
      \item |end|
      \item |extern|
      \item |false|
      \item |for|
      \item |fun|
      \item |if|
      \item |import|
      \item |in|
      \item |init|
      \item |interface|
      \item |intern|
      \item |intrude|
      \item |is|
      \item |isa|
      \item |isset|
      \item |loop|
      \item |label|
      \item |new|
      \item |not|
      \item |null|
      \item |nullable|
      \item |once|
      \item |or|
      \item |package|
      \item |print|
      \item |private|
      \item |protected|
      \item |readable|
      \item |redef|
      \item |return|
      \item |self|
      \item |special|
      \item |super|
      \item |then|
      \item |true|
      \item |type|
      \item |universal|
      \item |var|
      \item |while|
      \item |writable|
  \end{itemize}
\end{multicols}

\section{Convention d'écriture}

Quelques règles pour l'écriture d'un programme en Nit :
\begin{itemize}
    \item On préfèrera utiliser la notation basée sur le soulignement pour les variables. Par exemple : |ma_variable| ;
    \item Les types, comme les noms des classes seront écrits en \og CamelCase \fg. Par exemple : |MaClasse| ;
    \item L'indentation est faite avec le caractère de tabulation et est affichée comme 8 espaces ;
    \item Les opérateurs sont entourés d'espaces. Par exemple : |4 + 5| ou |x = 5| ;
    \item Les spécificateurs de type (|:|) et les virgules (|,|) ont un espace après mais pas avant. Par exemple : |var x: X| ou |[1, 2, 3]| ;
    \item Les parenthèses (|()|) et les crochets (|[]|) ne prennent pas d'espaces ;
    \item Le |do| des méthodes se trouve sur sa propre ligne et n'est pas indenté ;
    \item Le |do| des boucles se trouve sur la même ligne que la déclaration de la boucle ;
\end{itemize}

\section{Commentaires}
Les commentaires ne sont pas pris en compte par le compilateur. En Nit il existe seulement des commentaires sur une seule ligne grâce au caractère |#|. 
Il peuvent s'utiliser seulement sur une ligne ou alors en fin de ligne comme le montre l'exemple suivant : 
\lstinputlisting[language=Nit]{./syntaxe/listings/comment_s.nit}

A l'heure actuelle, Nit ne supporte pas les commentaires multi-lignes.

\chapter{Éléments de base de Nit}

\section{Déclaration et utilisation des variables}

Une variable possède un nom, un type et une valeur. Une variable est accessible et utilisable dans le bloc où elle est définie.

La déclaration d'une variable permet de réserver une zone de la mémoire pour y stocker une valeur.

En Nit les types peuvent être optionnels dans une déclaration. En effet, Nit est un langage statiquement typé par type adaptatif. C'est à dire qu'il est capable de \og deviner \fg le type de la variable déclarée en fonction de son utilisation.

Déclaration et affectation sur deux lignes en précisant le type :
\lstinputlisting[language=Nit, linerange=1-2]{./syntaxe/listings/declaration_s.nit}
Déclaration et affectation sur une seule ligne en précisant le type :
\lstinputlisting[language=Nit, linerange=3-3]{./syntaxe/listings/declaration_s.nit}
Déclaration et affectation sur une seule ligne sans préciser le type :
\lstinputlisting[language=Nit, linerange=4-4]{./syntaxe/listings/declaration_s.nit}

Ces trois exemples reviennent strictement au même. Dans le dernier exemple, lorsque l'on affecte 0 à la variable x, Nit comprend que |x| est de type |Int|.

Rappel : Les noms de variables en Nit peuvent commencer par une lettre ou par le caractères de soulignement. Le reste du nom peut comporter des lettres ou des nombres mais jamais d'espace.

Nit est un langage à typage rigoureux qui ne possède pas de transtypage automatique lorsque ce transtypage risque de conduire à une perte d'information ou à une erreur d'exécution.

Pour les objets, il est nécessaire en plus de la déclaration de la variable, de créer un objet avant de pouvoir l'utiliser. Il faut réserver de la mémoire pour la création d'un objet avec l'instruction |new|. Si l'objet n'est plus utilisé, la libération de la mémoire se fait automatiquement grâce au ramasse miettes.

Exemple d'utilisation du mot clé |new| :
\lstinputlisting[language=Nit]{./syntaxe/listings/new_s.nit}

Vous remarquerez qu'en Nit, il n'est pas nécessaire d'utiliser les parenthèses si le constructeur ne prend pas de paramètres.

\section{Type nullable}
Pour éviter les exceptions |nullPointerException| qui peuvent être fréquentes sur d'autres langages, Nit impose au développeur de préciser si une variable a le droit de prendre la valeur |null|.

Pour préciser qu'une variable peut prendre la valeur |null|, il faut utiliser le mot clé |nullable|.

Exemple :
\lstinputlisting[language=Nit, linerange=1]{./syntaxe/listings/nullable_c.nit}

En Nit, toute variable déclarée |nullable| mais qui n'a pas été initialisé a la valeur par défaut |null|. A l'inverse, une variable qui n'est pas déclarée |nullable| et n'est pas initialisée avant d'être utilisée provoquera une erreur de compilation.

\section{Affectation}
Le signe |=| est l'opérateur d'affectation et s'utilise avec une expression de la forme |variable = expression|.

Il existe des opérateurs qui permettent de simplifier l'écriture d'une opération d'affectation associée à un opérateur mathématique :

\begin{tabularx}{\linewidth}{|c|c|X|}
	\hline
	\textbf{Opérateur} & \textbf{Exemple} & \textbf{Signification} \\
	\hline
	= & a = 10 & équivalent à : a = 10 \\
	\hline
	+= & a += 10 & équivalent à : a = a + 10 \\
	\hline
	-= & a -= 10 & équivalent à : a = a - 10 \\
	\hline
\end{tabularx}

\pagebreak

\section{Comparaison}

Nit propose les opérateurs pour toutes les comparaisons :

\begin{tabularx}{\linewidth}{|c|c|X|}
	\hline
	\textbf{Opérateur} & \textbf{Exemple} & \textbf{Signification} \\
	\hline
	> & a > 10 & strictement supérieur \\
	\hline
	< & a < 10 & strictement inférieur \\
	\hline
	>= & a >= 10 & supérieur ou égal\\
	\hline
	<= & a <= 10 & inférieur ou égal\\
	\hline
	== & a <= 10 & égal\\
	\hline
    != & a != 10 & différent de\\
	\hline
	and & a and b & ET logique (pour expressions booléennes) : \newline l'évaluation de l'expression cesse dés qu'elle devient fausse\\
	\hline
	or & a or b & OU logique (pour expressions booléennes) : \newline l'évaluation de l'expression cesse dés qu'elle devient vraie\\
	\hline
    not & not b & NON logique\\
    \hline
\end{tabularx}


\section{Priorité des opérateurs}

Les opérateurs sont exécutés dans l'ordre suivant à l'intérieur d'une expression qui est analysée de gauche à droite :
\begin{itemize}
      \item multiplication, division et reste de division (modulo)
      \item addition et soustraction
      \item comparaison
      \item le signe |=| d'affectation d'une valeur à une variable
      \item NON logique
      \item ET logique
      \item OU logique
\end{itemize}

L'usage des parenthèses permet de modifier cet ordre de priorité.
	
\section{Structures de contrôles}

Comme les autres langages de développement, Nit propose un ensemble d'instructions qui permettent d'organiser et de structurer les traitements. L'usage de ces instructions est similaire à celui rencontré à leur équivalent dans d'autres langages.

\subsection{Boucles}
\subsubsection{While}
Dans une boucle |while|, le code est exécuté tant que la condition est vraie. Si avant l'instruction |while|, le booléen est faux, alors le code de la boucle ne sera jamais exécuté.

Exemple :
\lstinputlisting[language=Nit, linerange=1-6]{./syntaxe/listings/while_c.nit}

Le |while| peut aussi s'écrire sur une seule ligne :
\lstinputlisting[language=Nit, linerange=8]{./syntaxe/listings/while_c.nit}

\subsubsection{For}
En Nit, TOUT est objet et même les structures de contrôle. Ceci amène donc à une syntaxe un peu particulière. Ne vous en faites pas, on s'y fait !

Voici donc la syntaxe d'une boucle |for| :
\lstinputlisting[language=Nit, linerange=1-4]{./syntaxe/listings/for_c.nit}

On peut bien sûr utiliser des variables pour créer nos boucles :
\lstinputlisting[language=Nit, linerange=6-11]{./syntaxe/listings/for_c.nit}

Ou même des expressions :
\lstinputlisting[language=Nit, linerange=13-16]{./syntaxe/listings/for_c.nit}

Le |for| peut lui aussi s'écrire sur une ligne :
\lstinputlisting[language=Nit, linerange=18]{./syntaxe/listings/for_c.nit}

\subsubsection{Loop}
Les boucles infinies sont souvent utilisés accompagnées de l'instruction |break|. Elles sont utiles pour implémenter les boucles de type \og jusqu'à \fg \textit{untill} ou pour simuler le \textit{exit when} de Ada.

\lstinputlisting[language=Nit]{./syntaxe/listings/loop_c.nit}

\subsection{Blocs do}
Le |do| simple peut être utilisé pour déclarer des blocs de code ou jouer avec la portée des variables.

\lstinputlisting[language=Nit]{./syntaxe/listings/do_c.nit}

\subsection{Branchements conditionnels}
Avec Nit il n'existe qu'un seul type de branchement conditionnel : le |if|. On peut l'utiliser avec ou sans clause |else|. 

Exemple :
\lstinputlisting[language=Nit, linerange=1-7]{./syntaxe/listings/if_c.nit}

On peut aussi utiliser des clauses |else if| pour chaîner plusieurs tests :
\lstinputlisting[language=Nit, linerange=9-17]{./syntaxe/listings/if_c.nit}

Attention : Si on utilise un |else| ou un |else if|, l'instruction ne peut pas être écrit \textit{On Liner}.

\subsection{Débranchements}
|continue| permet de passer immédiatement à l'itération suivante dans une boucle |for|, |while| ou |loop| :
\lstinputlisting[language=Nit]{./syntaxe/listings/continue_c.nit}

|break| permet de quitter immédiatement une boucle |for|, |while|, |loop| ou un bloc |do| :
\lstinputlisting[language=Nit]{./syntaxe/listings/break_c.nit}

Des labels peuvent être utilisés pour spécifier sur quel élément |for|, |while|, |loop| ou |do| doit agir le break :
\lstinputlisting[language=Nit]{./syntaxe/listings/label_c.nit}

On peut aussi utiliser les labels de la même manière avec l'instruction |continue|.

\subsection{Arrêt du programme}
L'instruction |abort| permet d'arrêter le programme en lançant une erreur fatale.

\subsection{Assertions}
L'instruction |assert| vérifie si une expression booléenne est vrai, sinon elle arrêtera le programme comme |abort|. Elle peut être combinée à une clause |else| pour exécuter du code avant d'arrêter le programme :
\lstinputlisting[language=Nit]{./syntaxe/listings/assert_c.nit}

Comme on peut le voir dans l'exemple précédent, une étiquette peut être précisée pour être affichée dans le message d'erreur.

\section{Tableaux}
Les tableaux permettent de stocker un ensemble de valeur du même type dans la même variable. En Nit, la classe de base pour manipuler les tableaux est la classe |Array|. 

\subsection{Déclaration des tableaux}
Pour commencer, il va falloir instancier la classe |Array|. Chaque instance de |Array| ne peut contenir qu'un seul type de variable à la fois. Il faut préciser le type lors de l'instanciation grâce aux crochets |[]|.

\lstinputlisting[language=Nit, linerange=1]{./syntaxe/listings/array_c.nit}

Il est ensuite possible d'ajouter des valeurs dans le tableau en précisant dans quelle case du tableau on souhaite ajouter la valeur en utilisant l'opérateur |[]|. 

Exemple :
\lstinputlisting[language=Nit, linerange=3-4, firstnumber=last]{./syntaxe/listings/array_c.nit}

Ce même opérateur permet de récupérer les valeurs du tableau :
\lstinputlisting[language=Nit, linerange=6-7, firstnumber=last]{./syntaxe/listings/array_c.nit}

Attention, en Nit, la première case du tableau est la case 0 !

\subsection{Parcours d'un tableau}
On peut parcourir les tableaux grâce à une boucle |for| :
\lstinputlisting[language=Nit, linerange=3-5, firstnumber=last]{./syntaxe/listings/array2_c.nit}

\subsection{Initialisation explicite d'un tableau}
Il existe une manière plus rapide de créer les tableaux en initialisant explicitement le tableau avec les valeurs qu'il doit contenir.

\lstinputlisting[language=Nit, linerange=1]{./syntaxe/listings/array2_c.nit}

%\section{Intervalles}
%TODO vérifier et faire
%Il est possible de déclarer des intervalles |Range| basés sur des types discrets (comme |Int| par exemple). Il existe deux types d'intervalles : les intervalles ouverts |[1..5[| qui excluent le dernier élément, et les intervalles fermés |[1..5]| qui incluent le dernier élément.

%Par exemple :


\section{Conversions de types}
En Nit, il n'existe pas de mot clé de transtypage. Les conversions de types se font par des méthodes. La bibliothèque standard fournit une série de classes qui contiennent des méthodes de manipulation et de conversion de types.

\begin{tabularx}{\linewidth}{|c|X|}
	\hline
	\textbf{Classe} & \textbf{Rôle} \\
	\hline
	\textit{Char} & pour les caractères \\
	\hline
	\textit{String} & pour les chaînes de caractères \\
	\hline
	\textit{Int} & pour les entiers \\
	\hline
	\textit{Float} & pour les nombres à virgule flottante \\
	\hline
\end{tabularx}

Par exemple la classe \textit{Int} propose les méthodes suivantes :
\begin{description}
	\item[Int.to\_c: Char] Retourne le caractère correspondant.
	\item[Int.to\_f: Float] Retourne l'entier sous forme de |Float|.
	\item[Int.to\_s: String] Retourne l'entier sous forme de |String|.
\end{description}

\section{Manipulation de chaînes de caractères}
\subsection{Char et String}
La définition d'un caractère se fait grâce au type |Char|.

Pour assigner explicitement un caractère à une variable de type |Char|, il faut utiliser l'apostrophe |'|.

\lstinputlisting[language=Nit]{./syntaxe/listings/char1_c.nit}

La définition d'une chaine de caractères se fait grâce au type |String|.

Pour assigner explicitement un caractère à une variable de type |String|, il faut utiliser les guillemets |"|.

\lstinputlisting[language=Nit, linerange=1-1]{./syntaxe/listings/string_c.nit}

Les variables de type |Char| et |String| sont des objets. Partout où des constantes de caractères ou de chaînes figurent entre guillemets, le compilateur Nit génère l'objet correspondant avec le contenu spécifié. Il est donc possible d'écrire :
\lstinputlisting[language=Nit, linerange=3-3, firstnumber=last]{./syntaxe/listings/string_c.nit}

Bien que |Char| et |String| soient des classes, ils ne possèdent pas de constructeurs, il n'est donc pas possible de les initialiser en appelant la méthode |init|.

Attention, Nit ne supporte que l'encodage UTF-8 !

\subsection{Caractères spéciaux}

Dans une chaîne de caractères, plusieurs caractères particuliers doivent être échappés grâce au caractère |\| pour être utilisés. 

Le tableau ci-dessous recense les principaux caractères à échapper :

\begin{center}  
  \begin{tabular}{|c|c|}
      \hline
      \textbf{Caractères spéciaux} & \textbf{Affichage} \\
      \hline
      ' & apostrophe \\
      \hline
      " & guillemet \\
      \hline
      \lstinline!\! & antislash \\
      \hline
      \lstinline!\t! & tabulation \\
      \hline
      \lstinline!\b! & retour arrière (backspace) \\
      \hline
      \lstinline!\r! & retour chariot \\
      \hline
      \lstinline!\f! & saut de page \\
      \hline
      \lstinline!\n! & saut de ligne \\
      \hline
  \end{tabular}
\end{center}

\subsection{Concaténation de chaînes de caractères}

Il est possible de concaténer des chaînes de caractères à l'aide  de l'opérateur |+| et de le combiner à l'opérateur d'affectation |=|.

\lstinputlisting[language=Nit, linerange=5-5, firstnumber=last]{./syntaxe/listings/string_c.nit}

Pour concaténer un autre type avec un string, il faut faire appel à la méthode |to_s|.

Par exemple avec un Int :
\lstinputlisting[language=Nit, linerange=7-7]{./syntaxe/listings/string_c.nit}

Une notation particulière permet d'inclure une variable ou une expression dans une chaine de caractères :
\lstinputlisting[language=Nit, linerange=9-10]{./syntaxe/listings/string_c.nit}

La notation allégée appelle implicitement la méthode |to_s| sur les types autres que |String| :
\lstinputlisting[language=Nit, linerange=12-12]{./syntaxe/listings/string_c.nit}

La notation allégée sera préférée puisqu'elle est plus lisible mais aussi bien plus performante car traitée différemment pas le compilateur.

\subsection{Comparaison de chaînes de caractères}

En Nit il est possible de comparer deux chaînes de caractères directement grâce à l'opérateur |==|. Contrairement à Java par exemple, Nit va comparer la valeur des objets String est non pas les références vers les objets.
\lstinputlisting[language=Nit]{./syntaxe/listings/string2_c.nit}

\subsection{Autres opérations sur les chaînes de caractères}
Les méthodes |to_upper| et |to_lower| permettent respectivement d'obtenir une chaîne toute en majuscule ou toute en minuscule.

La méthodes |length| permet d'obtenir la taille de la chaîne.

On peut accéder aux caractères d'une chaine en utilisant la notation en tableau :
\lstinputlisting[language=Nit]{./syntaxe/listings/string3_c.nit}

Enfin, il est possible de répéter une chaine de caractères grâce à l'opérateur de multiplication |*| :
\lstinputlisting[language=Nit]{./syntaxe/listings/string4_c.nit}

\chapter{Typage Adaptatif}
\label{typage-adaptatif}
Nit est le premier langage à introduire la notion de \textbf{typage adaptatif}. Le principe est que le type statique d'une variable peut changer en fonction de l'assignation des variables et du contrôle de flot.

Par exemple :
\lstinputlisting[language=Nit]{./syntaxe/listings/typage_c.nit}

Les instructions de contrôle de flot vont elles aussi agir sur le typage de la variable :
\lstinputlisting[language=Nit]{./syntaxe/listings/typage2_c.nit}

Le typage adaptatif fonctionne aussi avec les types nullables :
\lstinputlisting[language=Nit]{./syntaxe/listings/typage3_c.nit}