# Production AST nodes full definition.
# This file was generated by SableCC (http://www.sablecc.org/).
module parser_prod is no_warning("missing-doc")

import lexer
intrude import parser_nodes
private import tables

redef class AModule
	init init_amodule (
		n_moduledecl: nullable AModuledecl,
		n_imports: Collection[Object], # Should be Collection[AImport]
		n_extern_code_blocks: Collection[Object], # Should be Collection[AExternCodeBlock]
		n_classdefs: Collection[Object] # Should be Collection[AClassdef]
	)
	do
		_n_moduledecl = n_moduledecl
		if n_moduledecl != null then n_moduledecl.parent = self
		self.n_imports.unsafe_add_all(n_imports)
		self.n_extern_code_blocks.unsafe_add_all(n_extern_code_blocks)
		self.n_classdefs.unsafe_add_all(n_classdefs)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_moduledecl == old_child then
			n_moduledecl = new_child.as(nullable AModuledecl)
			return
		end
		if n_imports.replace_child(old_child, new_child) then return
		if n_extern_code_blocks.replace_child(old_child, new_child) then return
		if n_classdefs.replace_child(old_child, new_child) then return
	end

	redef fun n_moduledecl=(node)
	do
		_n_moduledecl = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_moduledecl)
		n_imports.visit_all(v)
		n_extern_code_blocks.visit_all(v)
		n_classdefs.visit_all(v)
	end
end
redef class AModuledecl
	init init_amoduledecl (
		n_doc: nullable ADoc,
		n_kwredef: nullable TKwredef,
		n_visibility: nullable AVisibility,
		n_kwmodule: nullable TKwmodule,
		n_name: nullable AModuleName,
		n_annotations: nullable AAnnotations
	)
	do
		_n_doc = n_doc
		if n_doc != null then n_doc.parent = self
		_n_kwredef = n_kwredef
		if n_kwredef != null then n_kwredef.parent = self
		_n_visibility = n_visibility.as(not null)
		n_visibility.parent = self
		_n_kwmodule = n_kwmodule.as(not null)
		n_kwmodule.parent = self
		_n_name = n_name.as(not null)
		n_name.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if _n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if _n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if _n_kwmodule == old_child then
			n_kwmodule = new_child.as(TKwmodule)
			return
		end
		if _n_name == old_child then
			n_name = new_child.as(AModuleName)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_doc=(node)
	do
		_n_doc = node
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		_n_kwredef = node
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		_n_visibility = node
		node.parent = self
	end
	redef fun n_kwmodule=(node)
	do
		_n_kwmodule = node
		node.parent = self
	end
	redef fun n_name=(node)
	do
		_n_name = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_doc)
		v.enter_visit(_n_kwredef)
		v.enter_visit(_n_visibility)
		v.enter_visit(_n_kwmodule)
		v.enter_visit(_n_name)
		v.enter_visit(_n_annotations)
	end
end
redef class AStdImport
	init init_astdimport (
		n_visibility: nullable AVisibility,
		n_kwimport: nullable TKwimport,
		n_name: nullable AModuleName,
		n_annotations: nullable AAnnotations
	)
	do
		_n_visibility = n_visibility.as(not null)
		n_visibility.parent = self
		_n_kwimport = n_kwimport.as(not null)
		n_kwimport.parent = self
		_n_name = n_name.as(not null)
		n_name.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if _n_kwimport == old_child then
			n_kwimport = new_child.as(TKwimport)
			return
		end
		if _n_name == old_child then
			n_name = new_child.as(AModuleName)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_visibility=(node)
	do
		_n_visibility = node
		node.parent = self
	end
	redef fun n_kwimport=(node)
	do
		_n_kwimport = node
		node.parent = self
	end
	redef fun n_name=(node)
	do
		_n_name = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_visibility)
		v.enter_visit(_n_kwimport)
		v.enter_visit(_n_name)
		v.enter_visit(_n_annotations)
	end
end
redef class ANoImport
	init init_anoimport (
		n_visibility: nullable AVisibility,
		n_kwimport: nullable TKwimport,
		n_kwend: nullable TKwend
	)
	do
		_n_visibility = n_visibility.as(not null)
		n_visibility.parent = self
		_n_kwimport = n_kwimport.as(not null)
		n_kwimport.parent = self
		_n_kwend = n_kwend.as(not null)
		n_kwend.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if _n_kwimport == old_child then
			n_kwimport = new_child.as(TKwimport)
			return
		end
		if _n_kwend == old_child then
			n_kwend = new_child.as(TKwend)
			return
		end
	end

	redef fun n_visibility=(node)
	do
		_n_visibility = node
		node.parent = self
	end
	redef fun n_kwimport=(node)
	do
		_n_kwimport = node
		node.parent = self
	end
	redef fun n_kwend=(node)
	do
		_n_kwend = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_visibility)
		v.enter_visit(_n_kwimport)
		v.enter_visit(_n_kwend)
	end
end
redef class APublicVisibility
	init init_apublicvisibility (
		n_kwpublic: nullable TKwpublic
	)
	do
		_n_kwpublic = n_kwpublic
		if n_kwpublic != null then n_kwpublic.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwpublic == old_child then
			n_kwpublic = new_child.as(nullable TKwpublic)
			return
		end
	end

	redef fun n_kwpublic=(node)
	do
		_n_kwpublic = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwpublic)
	end
end
redef class APrivateVisibility
	init init_aprivatevisibility (
		n_kwprivate: nullable TKwprivate
	)
	do
		_n_kwprivate = n_kwprivate.as(not null)
		n_kwprivate.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwprivate == old_child then
			n_kwprivate = new_child.as(TKwprivate)
			return
		end
	end

	redef fun n_kwprivate=(node)
	do
		_n_kwprivate = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwprivate)
	end
end
redef class AProtectedVisibility
	init init_aprotectedvisibility (
		n_kwprotected: nullable TKwprotected
	)
	do
		_n_kwprotected = n_kwprotected.as(not null)
		n_kwprotected.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwprotected == old_child then
			n_kwprotected = new_child.as(TKwprotected)
			return
		end
	end

	redef fun n_kwprotected=(node)
	do
		_n_kwprotected = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwprotected)
	end
end
redef class AIntrudeVisibility
	init init_aintrudevisibility (
		n_kwintrude: nullable TKwintrude
	)
	do
		_n_kwintrude = n_kwintrude.as(not null)
		n_kwintrude.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwintrude == old_child then
			n_kwintrude = new_child.as(TKwintrude)
			return
		end
	end

	redef fun n_kwintrude=(node)
	do
		_n_kwintrude = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwintrude)
	end
end
redef class AStdClassdef
	init init_astdclassdef (
		n_doc: nullable ADoc,
		n_kwredef: nullable TKwredef,
		n_visibility: nullable AVisibility,
		n_classkind: nullable AClasskind,
		n_id: nullable TClassid,
		n_formaldefs: Collection[Object], # Should be Collection[AFormaldef]
		n_extern_code_block: nullable AExternCodeBlock,
		n_propdefs: Collection[Object], # Should be Collection[APropdef]
		n_kwend: nullable TKwend
	)
	do
		_n_doc = n_doc
		if n_doc != null then n_doc.parent = self
		_n_kwredef = n_kwredef
		if n_kwredef != null then n_kwredef.parent = self
		_n_visibility = n_visibility.as(not null)
		n_visibility.parent = self
		_n_classkind = n_classkind.as(not null)
		n_classkind.parent = self
		_n_id = n_id
		if n_id != null then n_id.parent = self
		self.n_formaldefs.unsafe_add_all(n_formaldefs)
		_n_extern_code_block = n_extern_code_block
		if n_extern_code_block != null then n_extern_code_block.parent = self
		self.n_propdefs.unsafe_add_all(n_propdefs)
		_n_kwend = n_kwend.as(not null)
		n_kwend.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if _n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if _n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if _n_classkind == old_child then
			n_classkind = new_child.as(AClasskind)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(nullable TClassid)
			return
		end
		if n_formaldefs.replace_child(old_child, new_child) then return
		if _n_extern_code_block == old_child then
			n_extern_code_block = new_child.as(nullable AExternCodeBlock)
			return
		end
		if n_propdefs.replace_child(old_child, new_child) then return
		if _n_kwend == old_child then
			n_kwend = new_child.as(TKwend)
			return
		end
	end

	redef fun n_doc=(node)
	do
		_n_doc = node
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		_n_kwredef = node
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		_n_visibility = node
		node.parent = self
	end
	redef fun n_classkind=(node)
	do
		_n_classkind = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		if node != null then node.parent = self
	end
	redef fun n_extern_code_block=(node)
	do
		_n_extern_code_block = node
		if node != null then node.parent = self
	end
	redef fun n_kwend=(node)
	do
		_n_kwend = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_doc)
		v.enter_visit(_n_kwredef)
		v.enter_visit(_n_visibility)
		v.enter_visit(_n_classkind)
		v.enter_visit(_n_id)
		n_formaldefs.visit_all(v)
		v.enter_visit(_n_extern_code_block)
		n_propdefs.visit_all(v)
		v.enter_visit(_n_kwend)
	end
end
redef class ATopClassdef
	init init_atopclassdef (
		n_propdefs: Collection[Object] # Should be Collection[APropdef]
	)
	do
		self.n_propdefs.unsafe_add_all(n_propdefs)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_propdefs.replace_child(old_child, new_child) then return
	end



	redef fun visit_all(v: Visitor)
	do
		n_propdefs.visit_all(v)
	end
end
redef class AMainClassdef
	init init_amainclassdef (
		n_propdefs: Collection[Object] # Should be Collection[APropdef]
	)
	do
		self.n_propdefs.unsafe_add_all(n_propdefs)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_propdefs.replace_child(old_child, new_child) then return
	end



	redef fun visit_all(v: Visitor)
	do
		n_propdefs.visit_all(v)
	end
end
redef class AConcreteClasskind
	init init_aconcreteclasskind (
		n_kwclass: nullable TKwclass
	)
	do
		_n_kwclass = n_kwclass.as(not null)
		n_kwclass.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwclass == old_child then
			n_kwclass = new_child.as(TKwclass)
			return
		end
	end

	redef fun n_kwclass=(node)
	do
		_n_kwclass = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwclass)
	end
end
redef class AAbstractClasskind
	init init_aabstractclasskind (
		n_kwabstract: nullable TKwabstract,
		n_kwclass: nullable TKwclass
	)
	do
		_n_kwabstract = n_kwabstract.as(not null)
		n_kwabstract.parent = self
		_n_kwclass = n_kwclass.as(not null)
		n_kwclass.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwabstract == old_child then
			n_kwabstract = new_child.as(TKwabstract)
			return
		end
		if _n_kwclass == old_child then
			n_kwclass = new_child.as(TKwclass)
			return
		end
	end

	redef fun n_kwabstract=(node)
	do
		_n_kwabstract = node
		node.parent = self
	end
	redef fun n_kwclass=(node)
	do
		_n_kwclass = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwabstract)
		v.enter_visit(_n_kwclass)
	end
end
redef class AInterfaceClasskind
	init init_ainterfaceclasskind (
		n_kwinterface: nullable TKwinterface
	)
	do
		_n_kwinterface = n_kwinterface.as(not null)
		n_kwinterface.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwinterface == old_child then
			n_kwinterface = new_child.as(TKwinterface)
			return
		end
	end

	redef fun n_kwinterface=(node)
	do
		_n_kwinterface = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwinterface)
	end
end
redef class AEnumClasskind
	init init_aenumclasskind (
		n_kwenum: nullable TKwenum
	)
	do
		_n_kwenum = n_kwenum.as(not null)
		n_kwenum.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwenum == old_child then
			n_kwenum = new_child.as(TKwenum)
			return
		end
	end

	redef fun n_kwenum=(node)
	do
		_n_kwenum = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwenum)
	end
end
redef class AExternClasskind
	init init_aexternclasskind (
		n_kwextern: nullable TKwextern,
		n_kwclass: nullable TKwclass
	)
	do
		_n_kwextern = n_kwextern.as(not null)
		n_kwextern.parent = self
		_n_kwclass = n_kwclass
		if n_kwclass != null then n_kwclass.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwextern == old_child then
			n_kwextern = new_child.as(TKwextern)
			return
		end
		if _n_kwclass == old_child then
			n_kwclass = new_child.as(nullable TKwclass)
			return
		end
	end

	redef fun n_kwextern=(node)
	do
		_n_kwextern = node
		node.parent = self
	end
	redef fun n_kwclass=(node)
	do
		_n_kwclass = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwextern)
		v.enter_visit(_n_kwclass)
	end
end
redef class AFormaldef
	init init_aformaldef (
		n_id: nullable TClassid,
		n_type: nullable AType,
		n_annotations: nullable AAnnotations
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_type = n_type
		if n_type != null then n_type.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TClassid)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
		v.enter_visit(_n_type)
		v.enter_visit(_n_annotations)
	end
end
redef class AAttrPropdef
	init init_aattrpropdef (
		n_doc: nullable ADoc,
		n_kwredef: nullable TKwredef,
		n_visibility: nullable AVisibility,
		n_kwvar: nullable TKwvar,
		n_id2: nullable TId,
		n_type: nullable AType,
		n_expr: nullable AExpr,
		n_annotations: nullable AAnnotations,
		n_block: nullable AExpr
	)
	do
		_n_doc = n_doc
		if n_doc != null then n_doc.parent = self
		_n_kwredef = n_kwredef
		if n_kwredef != null then n_kwredef.parent = self
		_n_visibility = n_visibility.as(not null)
		n_visibility.parent = self
		_n_kwvar = n_kwvar.as(not null)
		n_kwvar.parent = self
		_n_id2 = n_id2.as(not null)
		n_id2.parent = self
		_n_type = n_type
		if n_type != null then n_type.parent = self
		_n_expr = n_expr
		if n_expr != null then n_expr.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
		_n_block = n_block
		if n_block != null then n_block.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if _n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if _n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if _n_kwvar == old_child then
			n_kwvar = new_child.as(TKwvar)
			return
		end
		if _n_id2 == old_child then
			n_id2 = new_child.as(TId)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(nullable AExpr)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
		if _n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_doc=(node)
	do
		_n_doc = node
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		_n_kwredef = node
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		_n_visibility = node
		node.parent = self
	end
	redef fun n_kwvar=(node)
	do
		_n_kwvar = node
		node.parent = self
	end
	redef fun n_id2=(node)
	do
		_n_id2 = node
		node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		if node != null then node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end
	redef fun n_block=(node)
	do
		_n_block = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_doc)
		v.enter_visit(_n_kwredef)
		v.enter_visit(_n_visibility)
		v.enter_visit(_n_kwvar)
		v.enter_visit(_n_id2)
		v.enter_visit(_n_type)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_annotations)
		v.enter_visit(_n_block)
	end
end
redef class AMainMethPropdef
	init init_amainmethpropdef (
		n_kwredef: nullable TKwredef,
		n_block: nullable AExpr
	)
	do
		_n_kwredef = n_kwredef
		if n_kwredef != null then n_kwredef.parent = self
		_n_block = n_block
		if n_block != null then n_block.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if _n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_kwredef=(node)
	do
		_n_kwredef = node
		if node != null then node.parent = self
	end
	redef fun n_block=(node)
	do
		_n_block = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwredef)
		v.enter_visit(_n_block)
	end
end
redef class ATypePropdef
	init init_atypepropdef (
		n_doc: nullable ADoc,
		n_kwredef: nullable TKwredef,
		n_visibility: nullable AVisibility,
		n_kwtype: nullable TKwtype,
		n_id: nullable TClassid,
		n_type: nullable AType,
		n_annotations: nullable AAnnotations
	)
	do
		_n_doc = n_doc
		if n_doc != null then n_doc.parent = self
		_n_kwredef = n_kwredef
		if n_kwredef != null then n_kwredef.parent = self
		_n_visibility = n_visibility.as(not null)
		n_visibility.parent = self
		_n_kwtype = n_kwtype.as(not null)
		n_kwtype.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_type = n_type.as(not null)
		n_type.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if _n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if _n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if _n_kwtype == old_child then
			n_kwtype = new_child.as(TKwtype)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(TClassid)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_doc=(node)
	do
		_n_doc = node
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		_n_kwredef = node
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		_n_visibility = node
		node.parent = self
	end
	redef fun n_kwtype=(node)
	do
		_n_kwtype = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_doc)
		v.enter_visit(_n_kwredef)
		v.enter_visit(_n_visibility)
		v.enter_visit(_n_kwtype)
		v.enter_visit(_n_id)
		v.enter_visit(_n_type)
		v.enter_visit(_n_annotations)
	end
end
redef class AMethPropdef
	init init_amethpropdef (
		n_doc: nullable ADoc,
		n_kwredef: nullable TKwredef,
		n_visibility: nullable AVisibility,
		n_kwmeth: nullable TKwmeth,
		n_kwinit: nullable TKwinit,
		n_kwnew: nullable TKwnew,
		n_methid: nullable AMethid,
		n_signature: nullable ASignature,
		n_annotations: nullable AAnnotations,
		n_extern_calls: nullable AExternCalls,
		n_extern_code_block: nullable AExternCodeBlock,
		n_block: nullable AExpr
	)
	do
		_n_doc = n_doc
		if n_doc != null then n_doc.parent = self
		_n_kwredef = n_kwredef
		if n_kwredef != null then n_kwredef.parent = self
		_n_visibility = n_visibility.as(not null)
		n_visibility.parent = self
		_n_kwmeth = n_kwmeth
		if n_kwmeth != null then n_kwmeth.parent = self
		_n_kwinit = n_kwinit
		if n_kwinit != null then n_kwinit.parent = self
		_n_kwnew = n_kwnew
		if n_kwnew != null then n_kwnew.parent = self
		_n_methid = n_methid
		if n_methid != null then n_methid.parent = self
		_n_signature = n_signature.as(not null)
		n_signature.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
		_n_extern_calls = n_extern_calls
		if n_extern_calls != null then n_extern_calls.parent = self
		_n_extern_code_block = n_extern_code_block
		if n_extern_code_block != null then n_extern_code_block.parent = self
		_n_block = n_block
		if n_block != null then n_block.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if _n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if _n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if _n_kwmeth == old_child then
			n_kwmeth = new_child.as(nullable TKwmeth)
			return
		end
		if _n_kwinit == old_child then
			n_kwinit = new_child.as(nullable TKwinit)
			return
		end
		if _n_kwnew == old_child then
			n_kwnew = new_child.as(nullable TKwnew)
			return
		end
		if _n_methid == old_child then
			n_methid = new_child.as(nullable AMethid)
			return
		end
		if _n_signature == old_child then
			n_signature = new_child.as(ASignature)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
		if _n_extern_calls == old_child then
			n_extern_calls = new_child.as(nullable AExternCalls)
			return
		end
		if _n_extern_code_block == old_child then
			n_extern_code_block = new_child.as(nullable AExternCodeBlock)
			return
		end
		if _n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_doc=(node)
	do
		_n_doc = node
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		_n_kwredef = node
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		_n_visibility = node
		node.parent = self
	end
	redef fun n_kwmeth=(node)
	do
		_n_kwmeth = node
		if node != null then node.parent = self
	end
	redef fun n_kwinit=(node)
	do
		_n_kwinit = node
		if node != null then node.parent = self
	end
	redef fun n_kwnew=(node)
	do
		_n_kwnew = node
		if node != null then node.parent = self
	end
	redef fun n_methid=(node)
	do
		_n_methid = node
		if node != null then node.parent = self
	end
	redef fun n_signature=(node)
	do
		_n_signature = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end
	redef fun n_extern_calls=(node)
	do
		_n_extern_calls = node
		if node != null then node.parent = self
	end
	redef fun n_extern_code_block=(node)
	do
		_n_extern_code_block = node
		if node != null then node.parent = self
	end
	redef fun n_block=(node)
	do
		_n_block = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_doc)
		v.enter_visit(_n_kwredef)
		v.enter_visit(_n_visibility)
		v.enter_visit(_n_kwmeth)
		v.enter_visit(_n_kwinit)
		v.enter_visit(_n_kwnew)
		v.enter_visit(_n_methid)
		v.enter_visit(_n_signature)
		v.enter_visit(_n_annotations)
		v.enter_visit(_n_extern_calls)
		v.enter_visit(_n_extern_code_block)
		v.enter_visit(_n_block)
	end
end
redef class ASuperPropdef
	init init_asuperpropdef (
		n_doc: nullable ADoc,
		n_kwredef: nullable TKwredef,
		n_visibility: nullable AVisibility,
		n_kwsuper: nullable TKwsuper,
		n_type: nullable AType,
		n_annotations: nullable AAnnotations
	)
	do
		_n_doc = n_doc
		if n_doc != null then n_doc.parent = self
		_n_kwredef = n_kwredef
		if n_kwredef != null then n_kwredef.parent = self
		_n_visibility = n_visibility.as(not null)
		n_visibility.parent = self
		_n_kwsuper = n_kwsuper.as(not null)
		n_kwsuper.parent = self
		_n_type = n_type.as(not null)
		n_type.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if _n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if _n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if _n_kwsuper == old_child then
			n_kwsuper = new_child.as(TKwsuper)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_doc=(node)
	do
		_n_doc = node
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		_n_kwredef = node
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		_n_visibility = node
		node.parent = self
	end
	redef fun n_kwsuper=(node)
	do
		_n_kwsuper = node
		node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_doc)
		v.enter_visit(_n_kwredef)
		v.enter_visit(_n_visibility)
		v.enter_visit(_n_kwsuper)
		v.enter_visit(_n_type)
		v.enter_visit(_n_annotations)
	end
end
redef class AAnnotPropdef
	init init_aannotpropdef (
		n_doc: nullable ADoc,
		n_kwredef: nullable TKwredef,
		n_visibility: nullable AVisibility,
		n_atid: nullable AAtid,
		n_opar: nullable TOpar,
		n_args: Collection[Object], # Should be Collection[AExpr]
		n_cpar: nullable TCpar,
		n_annotations: nullable AAnnotations
	)
	do
		_n_doc = n_doc
		if n_doc != null then n_doc.parent = self
		_n_kwredef = n_kwredef
		if n_kwredef != null then n_kwredef.parent = self
		_n_visibility = n_visibility
		if n_visibility != null then n_visibility.parent = self
		_n_atid = n_atid.as(not null)
		n_atid.parent = self
		_n_opar = n_opar
		if n_opar != null then n_opar.parent = self
		self.n_args.unsafe_add_all(n_args)
		_n_cpar = n_cpar
		if n_cpar != null then n_cpar.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if _n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if _n_visibility == old_child then
			n_visibility = new_child.as(nullable AVisibility)
			return
		end
		if _n_atid == old_child then
			n_atid = new_child.as(AAtid)
			return
		end
		if _n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if n_args.replace_child(old_child, new_child) then return
		if _n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_doc=(node)
	do
		_n_doc = node
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		_n_kwredef = node
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		_n_visibility = node
		if node != null then node.parent = self
	end
	redef fun n_atid=(node)
	do
		_n_atid = node
		node.parent = self
	end
	redef fun n_opar=(node)
	do
		_n_opar = node
		if node != null then node.parent = self
	end
	redef fun n_cpar=(node)
	do
		_n_cpar = node
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_doc)
		v.enter_visit(_n_kwredef)
		v.enter_visit(_n_visibility)
		v.enter_visit(_n_atid)
		v.enter_visit(_n_opar)
		n_args.visit_all(v)
		v.enter_visit(_n_cpar)
		v.enter_visit(_n_annotations)
	end
end
redef class AIdMethid
	init init_aidmethid (
		n_id: nullable TId
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
	end
end
redef class APlusMethid
	init init_aplusmethid (
		n_plus: nullable TPlus
	)
	do
		_n_plus = n_plus.as(not null)
		n_plus.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_plus == old_child then
			n_plus = new_child.as(TPlus)
			return
		end
	end

	redef fun n_plus=(node)
	do
		_n_plus = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_plus)
	end
end
redef class AMinusMethid
	init init_aminusmethid (
		n_minus: nullable TMinus
	)
	do
		_n_minus = n_minus.as(not null)
		n_minus.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_minus == old_child then
			n_minus = new_child.as(TMinus)
			return
		end
	end

	redef fun n_minus=(node)
	do
		_n_minus = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_minus)
	end
end
redef class AStarMethid
	init init_astarmethid (
		n_star: nullable TStar
	)
	do
		_n_star = n_star.as(not null)
		n_star.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_star == old_child then
			n_star = new_child.as(TStar)
			return
		end
	end

	redef fun n_star=(node)
	do
		_n_star = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_star)
	end
end
redef class AStarstarMethid
	init init_astarstarmethid (
		n_starstar: nullable TStarstar
	)
	do
		_n_starstar = n_starstar.as(not null)
		n_starstar.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_starstar == old_child then
			n_starstar = new_child.as(TStarstar)
			return
		end
	end

	redef fun n_starstar=(node)
	do
		_n_starstar = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_starstar)
	end
end
redef class ASlashMethid
	init init_aslashmethid (
		n_slash: nullable TSlash
	)
	do
		_n_slash = n_slash.as(not null)
		n_slash.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_slash == old_child then
			n_slash = new_child.as(TSlash)
			return
		end
	end

	redef fun n_slash=(node)
	do
		_n_slash = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_slash)
	end
end
redef class APercentMethid
	init init_apercentmethid (
		n_percent: nullable TPercent
	)
	do
		_n_percent = n_percent.as(not null)
		n_percent.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_percent == old_child then
			n_percent = new_child.as(TPercent)
			return
		end
	end

	redef fun n_percent=(node)
	do
		_n_percent = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_percent)
	end
end
redef class AEqMethid
	init init_aeqmethid (
		n_eq: nullable TEq
	)
	do
		_n_eq = n_eq.as(not null)
		n_eq.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_eq == old_child then
			n_eq = new_child.as(TEq)
			return
		end
	end

	redef fun n_eq=(node)
	do
		_n_eq = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_eq)
	end
end
redef class ANeMethid
	init init_anemethid (
		n_ne: nullable TNe
	)
	do
		_n_ne = n_ne.as(not null)
		n_ne.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_ne == old_child then
			n_ne = new_child.as(TNe)
			return
		end
	end

	redef fun n_ne=(node)
	do
		_n_ne = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_ne)
	end
end
redef class ALeMethid
	init init_alemethid (
		n_le: nullable TLe
	)
	do
		_n_le = n_le.as(not null)
		n_le.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_le == old_child then
			n_le = new_child.as(TLe)
			return
		end
	end

	redef fun n_le=(node)
	do
		_n_le = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_le)
	end
end
redef class AGeMethid
	init init_agemethid (
		n_ge: nullable TGe
	)
	do
		_n_ge = n_ge.as(not null)
		n_ge.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_ge == old_child then
			n_ge = new_child.as(TGe)
			return
		end
	end

	redef fun n_ge=(node)
	do
		_n_ge = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_ge)
	end
end
redef class ALtMethid
	init init_altmethid (
		n_lt: nullable TLt
	)
	do
		_n_lt = n_lt.as(not null)
		n_lt.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_lt == old_child then
			n_lt = new_child.as(TLt)
			return
		end
	end

	redef fun n_lt=(node)
	do
		_n_lt = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_lt)
	end
end
redef class AGtMethid
	init init_agtmethid (
		n_gt: nullable TGt
	)
	do
		_n_gt = n_gt.as(not null)
		n_gt.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_gt == old_child then
			n_gt = new_child.as(TGt)
			return
		end
	end

	redef fun n_gt=(node)
	do
		_n_gt = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_gt)
	end
end
redef class ALlMethid
	init init_allmethid (
		n_ll: nullable TLl
	)
	do
		_n_ll = n_ll.as(not null)
		n_ll.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_ll == old_child then
			n_ll = new_child.as(TLl)
			return
		end
	end

	redef fun n_ll=(node)
	do
		_n_ll = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_ll)
	end
end
redef class AGgMethid
	init init_aggmethid (
		n_gg: nullable TGg
	)
	do
		_n_gg = n_gg.as(not null)
		n_gg.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_gg == old_child then
			n_gg = new_child.as(TGg)
			return
		end
	end

	redef fun n_gg=(node)
	do
		_n_gg = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_gg)
	end
end
redef class ABraMethid
	init init_abramethid (
		n_obra: nullable TObra,
		n_cbra: nullable TCbra
	)
	do
		_n_obra = n_obra.as(not null)
		n_obra.parent = self
		_n_cbra = n_cbra.as(not null)
		n_cbra.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if _n_cbra == old_child then
			n_cbra = new_child.as(TCbra)
			return
		end
	end

	redef fun n_obra=(node)
	do
		_n_obra = node
		node.parent = self
	end
	redef fun n_cbra=(node)
	do
		_n_cbra = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_obra)
		v.enter_visit(_n_cbra)
	end
end
redef class AStarshipMethid
	init init_astarshipmethid (
		n_starship: nullable TStarship
	)
	do
		_n_starship = n_starship.as(not null)
		n_starship.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_starship == old_child then
			n_starship = new_child.as(TStarship)
			return
		end
	end

	redef fun n_starship=(node)
	do
		_n_starship = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_starship)
	end
end
redef class AAssignMethid
	init init_aassignmethid (
		n_id: nullable TId,
		n_assign: nullable TAssign
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_assign = n_assign.as(not null)
		n_assign.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if _n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		_n_assign = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
		v.enter_visit(_n_assign)
	end
end
redef class ABraassignMethid
	init init_abraassignmethid (
		n_obra: nullable TObra,
		n_cbra: nullable TCbra,
		n_assign: nullable TAssign
	)
	do
		_n_obra = n_obra.as(not null)
		n_obra.parent = self
		_n_cbra = n_cbra.as(not null)
		n_cbra.parent = self
		_n_assign = n_assign.as(not null)
		n_assign.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if _n_cbra == old_child then
			n_cbra = new_child.as(TCbra)
			return
		end
		if _n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
	end

	redef fun n_obra=(node)
	do
		_n_obra = node
		node.parent = self
	end
	redef fun n_cbra=(node)
	do
		_n_cbra = node
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		_n_assign = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_obra)
		v.enter_visit(_n_cbra)
		v.enter_visit(_n_assign)
	end
end
redef class ASignature
	init init_asignature (
		n_opar: nullable TOpar,
		n_params: Collection[Object], # Should be Collection[AParam]
		n_cpar: nullable TCpar,
		n_type: nullable AType
	)
	do
		_n_opar = n_opar
		if n_opar != null then n_opar.parent = self
		self.n_params.unsafe_add_all(n_params)
		_n_cpar = n_cpar
		if n_cpar != null then n_cpar.parent = self
		_n_type = n_type
		if n_type != null then n_type.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if n_params.replace_child(old_child, new_child) then return
		if _n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
	end

	redef fun n_opar=(node)
	do
		_n_opar = node
		if node != null then node.parent = self
	end
	redef fun n_cpar=(node)
	do
		_n_cpar = node
		if node != null then node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_opar)
		n_params.visit_all(v)
		v.enter_visit(_n_cpar)
		v.enter_visit(_n_type)
	end
end
redef class AParam
	init init_aparam (
		n_id: nullable TId,
		n_type: nullable AType,
		n_dotdotdot: nullable TDotdotdot,
		n_annotations: nullable AAnnotations
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_type = n_type
		if n_type != null then n_type.parent = self
		_n_dotdotdot = n_dotdotdot
		if n_dotdotdot != null then n_dotdotdot.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
		if _n_dotdotdot == old_child then
			n_dotdotdot = new_child.as(nullable TDotdotdot)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		if node != null then node.parent = self
	end
	redef fun n_dotdotdot=(node)
	do
		_n_dotdotdot = node
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
		v.enter_visit(_n_type)
		v.enter_visit(_n_dotdotdot)
		v.enter_visit(_n_annotations)
	end
end
redef class AType
	init init_atype (
		n_kwnullable: nullable TKwnullable,
		n_id: nullable TClassid,
		n_types: Collection[Object], # Should be Collection[AType]
		n_annotations: nullable AAnnotations
	)
	do
		_n_kwnullable = n_kwnullable
		if n_kwnullable != null then n_kwnullable.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
		self.n_types.unsafe_add_all(n_types)
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwnullable == old_child then
			n_kwnullable = new_child.as(nullable TKwnullable)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(TClassid)
			return
		end
		if n_types.replace_child(old_child, new_child) then return
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwnullable=(node)
	do
		_n_kwnullable = node
		if node != null then node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwnullable)
		v.enter_visit(_n_id)
		n_types.visit_all(v)
		v.enter_visit(_n_annotations)
	end
end
redef class ALabel
	init init_alabel (
		n_kwlabel: nullable TKwlabel,
		n_id: nullable TId
	)
	do
		_n_kwlabel = n_kwlabel.as(not null)
		n_kwlabel.parent = self
		_n_id = n_id
		if n_id != null then n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwlabel == old_child then
			n_kwlabel = new_child.as(TKwlabel)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(nullable TId)
			return
		end
	end

	redef fun n_kwlabel=(node)
	do
		_n_kwlabel = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwlabel)
		v.enter_visit(_n_id)
	end
end
redef class ABlockExpr
	init init_ablockexpr (
		n_expr: Collection[Object], # Should be Collection[AExpr]
		n_kwend: nullable TKwend
	)
	do
		self.n_expr.unsafe_add_all(n_expr)
		_n_kwend = n_kwend
		if n_kwend != null then n_kwend.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr.replace_child(old_child, new_child) then return
		if _n_kwend == old_child then
			n_kwend = new_child.as(nullable TKwend)
			return
		end
	end

	redef fun n_kwend=(node)
	do
		_n_kwend = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		n_expr.visit_all(v)
		v.enter_visit(_n_kwend)
	end
end
redef class AVardeclExpr
	init init_avardeclexpr (
		n_kwvar: nullable TKwvar,
		n_id: nullable TId,
		n_type: nullable AType,
		n_assign: nullable TAssign,
		n_expr: nullable AExpr,
		n_annotations: nullable AAnnotations
	)
	do
		_n_kwvar = n_kwvar
		if n_kwvar != null then n_kwvar.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_type = n_type
		if n_type != null then n_type.parent = self
		_n_assign = n_assign
		if n_assign != null then n_assign.parent = self
		_n_expr = n_expr
		if n_expr != null then n_expr.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwvar == old_child then
			n_kwvar = new_child.as(nullable TKwvar)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
		if _n_assign == old_child then
			n_assign = new_child.as(nullable TAssign)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(nullable AExpr)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwvar=(node)
	do
		_n_kwvar = node
		if node != null then node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		if node != null then node.parent = self
	end
	redef fun n_assign=(node)
	do
		_n_assign = node
		if node != null then node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwvar)
		v.enter_visit(_n_id)
		v.enter_visit(_n_type)
		v.enter_visit(_n_assign)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_annotations)
	end
end
redef class AReturnExpr
	init init_areturnexpr (
		n_kwreturn: nullable TKwreturn,
		n_expr: nullable AExpr
	)
	do
		_n_kwreturn = n_kwreturn
		if n_kwreturn != null then n_kwreturn.parent = self
		_n_expr = n_expr
		if n_expr != null then n_expr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwreturn == old_child then
			n_kwreturn = new_child.as(nullable TKwreturn)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_kwreturn=(node)
	do
		_n_kwreturn = node
		if node != null then node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwreturn)
		v.enter_visit(_n_expr)
	end
end
redef class ABreakExpr
	init init_abreakexpr (
		n_kwbreak: nullable TKwbreak,
		n_label: nullable ALabel
	)
	do
		_n_kwbreak = n_kwbreak.as(not null)
		n_kwbreak.parent = self
		_n_label = n_label
		if n_label != null then n_label.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwbreak == old_child then
			n_kwbreak = new_child.as(TKwbreak)
			return
		end
		if _n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwbreak=(node)
	do
		_n_kwbreak = node
		node.parent = self
	end
	redef fun n_label=(node)
	do
		_n_label = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwbreak)
		v.enter_visit(_n_label)
	end
end
redef class AAbortExpr
	init init_aabortexpr (
		n_kwabort: nullable TKwabort
	)
	do
		_n_kwabort = n_kwabort.as(not null)
		n_kwabort.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwabort == old_child then
			n_kwabort = new_child.as(TKwabort)
			return
		end
	end

	redef fun n_kwabort=(node)
	do
		_n_kwabort = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwabort)
	end
end
redef class AContinueExpr
	init init_acontinueexpr (
		n_kwcontinue: nullable TKwcontinue,
		n_label: nullable ALabel
	)
	do
		_n_kwcontinue = n_kwcontinue
		if n_kwcontinue != null then n_kwcontinue.parent = self
		_n_label = n_label
		if n_label != null then n_label.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwcontinue == old_child then
			n_kwcontinue = new_child.as(nullable TKwcontinue)
			return
		end
		if _n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwcontinue=(node)
	do
		_n_kwcontinue = node
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		_n_label = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwcontinue)
		v.enter_visit(_n_label)
	end
end
redef class ADoExpr
	init init_adoexpr (
		n_kwdo: nullable TKwdo,
		n_block: nullable AExpr,
		n_label: nullable ALabel
	)
	do
		_n_kwdo = n_kwdo.as(not null)
		n_kwdo.parent = self
		_n_block = n_block
		if n_block != null then n_block.parent = self
		_n_label = n_label
		if n_label != null then n_label.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwdo == old_child then
			n_kwdo = new_child.as(TKwdo)
			return
		end
		if _n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
		if _n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwdo=(node)
	do
		_n_kwdo = node
		node.parent = self
	end
	redef fun n_block=(node)
	do
		_n_block = node
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		_n_label = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwdo)
		v.enter_visit(_n_block)
		v.enter_visit(_n_label)
	end
end
redef class AIfExpr
	init init_aifexpr (
		n_kwif: nullable TKwif,
		n_expr: nullable AExpr,
		n_then: nullable AExpr,
		n_else: nullable AExpr
	)
	do
		_n_kwif = n_kwif.as(not null)
		n_kwif.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_then = n_then
		if n_then != null then n_then.parent = self
		_n_else = n_else
		if n_else != null then n_else.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwif == old_child then
			n_kwif = new_child.as(TKwif)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_then == old_child then
			n_then = new_child.as(nullable AExpr)
			return
		end
		if _n_else == old_child then
			n_else = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_kwif=(node)
	do
		_n_kwif = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_then=(node)
	do
		_n_then = node
		if node != null then node.parent = self
	end
	redef fun n_else=(node)
	do
		_n_else = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwif)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_then)
		v.enter_visit(_n_else)
	end
end
redef class AIfexprExpr
	init init_aifexprexpr (
		n_kwif: nullable TKwif,
		n_expr: nullable AExpr,
		n_kwthen: nullable TKwthen,
		n_then: nullable AExpr,
		n_kwelse: nullable TKwelse,
		n_else: nullable AExpr
	)
	do
		_n_kwif = n_kwif.as(not null)
		n_kwif.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_kwthen = n_kwthen.as(not null)
		n_kwthen.parent = self
		_n_then = n_then.as(not null)
		n_then.parent = self
		_n_kwelse = n_kwelse.as(not null)
		n_kwelse.parent = self
		_n_else = n_else.as(not null)
		n_else.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwif == old_child then
			n_kwif = new_child.as(TKwif)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_kwthen == old_child then
			n_kwthen = new_child.as(TKwthen)
			return
		end
		if _n_then == old_child then
			n_then = new_child.as(AExpr)
			return
		end
		if _n_kwelse == old_child then
			n_kwelse = new_child.as(TKwelse)
			return
		end
		if _n_else == old_child then
			n_else = new_child.as(AExpr)
			return
		end
	end

	redef fun n_kwif=(node)
	do
		_n_kwif = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_kwthen=(node)
	do
		_n_kwthen = node
		node.parent = self
	end
	redef fun n_then=(node)
	do
		_n_then = node
		node.parent = self
	end
	redef fun n_kwelse=(node)
	do
		_n_kwelse = node
		node.parent = self
	end
	redef fun n_else=(node)
	do
		_n_else = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwif)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_kwthen)
		v.enter_visit(_n_then)
		v.enter_visit(_n_kwelse)
		v.enter_visit(_n_else)
	end
end
redef class AWhileExpr
	init init_awhileexpr (
		n_kwwhile: nullable TKwwhile,
		n_expr: nullable AExpr,
		n_kwdo: nullable TKwdo,
		n_block: nullable AExpr,
		n_label: nullable ALabel
	)
	do
		_n_kwwhile = n_kwwhile.as(not null)
		n_kwwhile.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_kwdo = n_kwdo.as(not null)
		n_kwdo.parent = self
		_n_block = n_block
		if n_block != null then n_block.parent = self
		_n_label = n_label
		if n_label != null then n_label.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwwhile == old_child then
			n_kwwhile = new_child.as(TKwwhile)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_kwdo == old_child then
			n_kwdo = new_child.as(TKwdo)
			return
		end
		if _n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
		if _n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwwhile=(node)
	do
		_n_kwwhile = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_kwdo=(node)
	do
		_n_kwdo = node
		node.parent = self
	end
	redef fun n_block=(node)
	do
		_n_block = node
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		_n_label = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwwhile)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_kwdo)
		v.enter_visit(_n_block)
		v.enter_visit(_n_label)
	end
end
redef class ALoopExpr
	init init_aloopexpr (
		n_kwloop: nullable TKwloop,
		n_block: nullable AExpr,
		n_label: nullable ALabel
	)
	do
		_n_kwloop = n_kwloop.as(not null)
		n_kwloop.parent = self
		_n_block = n_block
		if n_block != null then n_block.parent = self
		_n_label = n_label
		if n_label != null then n_label.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwloop == old_child then
			n_kwloop = new_child.as(TKwloop)
			return
		end
		if _n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
		if _n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwloop=(node)
	do
		_n_kwloop = node
		node.parent = self
	end
	redef fun n_block=(node)
	do
		_n_block = node
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		_n_label = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwloop)
		v.enter_visit(_n_block)
		v.enter_visit(_n_label)
	end
end
redef class AForExpr
	init init_aforexpr (
		n_kwfor: nullable TKwfor,
		n_ids: Collection[Object], # Should be Collection[TId]
		n_expr: nullable AExpr,
		n_kwdo: nullable TKwdo,
		n_block: nullable AExpr,
		n_label: nullable ALabel
	)
	do
		_n_kwfor = n_kwfor.as(not null)
		n_kwfor.parent = self
		self.n_ids.unsafe_add_all(n_ids)
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_kwdo = n_kwdo.as(not null)
		n_kwdo.parent = self
		_n_block = n_block
		if n_block != null then n_block.parent = self
		_n_label = n_label
		if n_label != null then n_label.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwfor == old_child then
			n_kwfor = new_child.as(TKwfor)
			return
		end
		if n_ids.replace_child(old_child, new_child) then return
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_kwdo == old_child then
			n_kwdo = new_child.as(TKwdo)
			return
		end
		if _n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
		if _n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwfor=(node)
	do
		_n_kwfor = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_kwdo=(node)
	do
		_n_kwdo = node
		node.parent = self
	end
	redef fun n_block=(node)
	do
		_n_block = node
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		_n_label = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwfor)
		n_ids.visit_all(v)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_kwdo)
		v.enter_visit(_n_block)
		v.enter_visit(_n_label)
	end
end
redef class AWithExpr
	init init_awithexpr (
		n_kwwith: nullable TKwwith,
		n_expr: nullable AExpr,
		n_kwdo: nullable TKwdo,
		n_block: nullable AExpr,
		n_label: nullable ALabel
	)
	do
		_n_kwwith = n_kwwith.as(not null)
		n_kwwith.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_kwdo = n_kwdo.as(not null)
		n_kwdo.parent = self
		_n_block = n_block
		if n_block != null then n_block.parent = self
		_n_label = n_label
		if n_label != null then n_label.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwwith == old_child then
			n_kwwith = new_child.as(TKwwith)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_kwdo == old_child then
			n_kwdo = new_child.as(TKwdo)
			return
		end
		if _n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
		if _n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwwith=(node)
	do
		_n_kwwith = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_kwdo=(node)
	do
		_n_kwdo = node
		node.parent = self
	end
	redef fun n_block=(node)
	do
		_n_block = node
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		_n_label = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwwith)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_kwdo)
		v.enter_visit(_n_block)
		v.enter_visit(_n_label)
	end
end
redef class AAssertExpr
	init init_aassertexpr (
		n_kwassert: nullable TKwassert,
		n_id: nullable TId,
		n_expr: nullable AExpr,
		n_else: nullable AExpr
	)
	do
		_n_kwassert = n_kwassert.as(not null)
		n_kwassert.parent = self
		_n_id = n_id
		if n_id != null then n_id.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_else = n_else
		if n_else != null then n_else.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwassert == old_child then
			n_kwassert = new_child.as(TKwassert)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(nullable TId)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_else == old_child then
			n_else = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_kwassert=(node)
	do
		_n_kwassert = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		if node != null then node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_else=(node)
	do
		_n_else = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwassert)
		v.enter_visit(_n_id)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_else)
	end
end
redef class AOnceExpr
	init init_aonceexpr (
		n_kwonce: nullable TKwonce,
		n_expr: nullable AExpr
	)
	do
		_n_kwonce = n_kwonce.as(not null)
		n_kwonce.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwonce == old_child then
			n_kwonce = new_child.as(TKwonce)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
	end

	redef fun n_kwonce=(node)
	do
		_n_kwonce = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwonce)
		v.enter_visit(_n_expr)
	end
end
redef class ASendExpr
	init init_asendexpr (
		n_expr: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
	end
end
redef class ABinopExpr
	init init_abinopexpr (
		n_expr: nullable AExpr,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_expr2)
	end
end
redef class AOrExpr
	init init_aorexpr (
		n_expr: nullable AExpr,
		n_op: nullable TKwor,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TKwor)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AAndExpr
	init init_aandexpr (
		n_expr: nullable AExpr,
		n_op: nullable TKwand,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TKwand)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AOrElseExpr
	init init_aorelseexpr (
		n_expr: nullable AExpr,
		n_op: nullable TKwor,
		n_kwelse: nullable TKwelse,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_kwelse = n_kwelse.as(not null)
		n_kwelse.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TKwor)
			return
		end
		if _n_kwelse == old_child then
			n_kwelse = new_child.as(TKwelse)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_kwelse=(node)
	do
		_n_kwelse = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_kwelse)
		v.enter_visit(_n_expr2)
	end
end
redef class AImpliesExpr
	init init_aimpliesexpr (
		n_expr: nullable AExpr,
		n_op: nullable TKwimplies,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TKwimplies)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class ANotExpr
	init init_anotexpr (
		n_kwnot: nullable TKwnot,
		n_expr: nullable AExpr
	)
	do
		_n_kwnot = n_kwnot.as(not null)
		n_kwnot.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwnot == old_child then
			n_kwnot = new_child.as(TKwnot)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
	end

	redef fun n_kwnot=(node)
	do
		_n_kwnot = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwnot)
		v.enter_visit(_n_expr)
	end
end
redef class AEqExpr
	init init_aeqexpr (
		n_expr: nullable AExpr,
		n_op: nullable TEq,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TEq)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class ANeExpr
	init init_aneexpr (
		n_expr: nullable AExpr,
		n_op: nullable TNe,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TNe)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class ALtExpr
	init init_altexpr (
		n_expr: nullable AExpr,
		n_op: nullable TLt,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TLt)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class ALeExpr
	init init_aleexpr (
		n_expr: nullable AExpr,
		n_op: nullable TLe,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TLe)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class ALlExpr
	init init_allexpr (
		n_expr: nullable AExpr,
		n_op: nullable TLl,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TLl)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AGtExpr
	init init_agtexpr (
		n_expr: nullable AExpr,
		n_op: nullable TGt,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TGt)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AGeExpr
	init init_ageexpr (
		n_expr: nullable AExpr,
		n_op: nullable TGe,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TGe)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AGgExpr
	init init_aggexpr (
		n_expr: nullable AExpr,
		n_op: nullable TGg,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TGg)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AIsaExpr
	init init_aisaexpr (
		n_expr: nullable AExpr,
		n_kwisa: nullable TKwisa,
		n_type: nullable AType
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_kwisa = n_kwisa.as(not null)
		n_kwisa.parent = self
		_n_type = n_type.as(not null)
		n_type.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_kwisa == old_child then
			n_kwisa = new_child.as(TKwisa)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_kwisa=(node)
	do
		_n_kwisa = node
		node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_kwisa)
		v.enter_visit(_n_type)
	end
end
redef class APlusExpr
	init init_aplusexpr (
		n_expr: nullable AExpr,
		n_op: nullable TPlus,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TPlus)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AMinusExpr
	init init_aminusexpr (
		n_expr: nullable AExpr,
		n_op: nullable TMinus,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TMinus)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AStarshipExpr
	init init_astarshipexpr (
		n_expr: nullable AExpr,
		n_op: nullable TStarship,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TStarship)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AStarExpr
	init init_astarexpr (
		n_expr: nullable AExpr,
		n_op: nullable TStar,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TStar)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AStarstarExpr
	init init_astarstarexpr (
		n_expr: nullable AExpr,
		n_op: nullable TStarstar,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TStarstar)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class ASlashExpr
	init init_aslashexpr (
		n_expr: nullable AExpr,
		n_op: nullable TSlash,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TSlash)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class APercentExpr
	init init_apercentexpr (
		n_expr: nullable AExpr,
		n_op: nullable TPercent,
		n_expr2: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_op = n_op.as(not null)
		n_op.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_op == old_child then
			n_op = new_child.as(TPercent)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_op)
		v.enter_visit(_n_expr2)
	end
end
redef class AUminusExpr
	init init_auminusexpr (
		n_minus: nullable TMinus,
		n_expr: nullable AExpr
	)
	do
		_n_minus = n_minus.as(not null)
		n_minus.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_minus == old_child then
			n_minus = new_child.as(TMinus)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
	end

	redef fun n_minus=(node)
	do
		_n_minus = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_minus)
		v.enter_visit(_n_expr)
	end
end
redef class AUplusExpr
	init init_auplusexpr (
		n_plus: nullable TPlus,
		n_expr: nullable AExpr
	)
	do
		_n_plus = n_plus.as(not null)
		n_plus.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_plus == old_child then
			n_plus = new_child.as(TPlus)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
	end

	redef fun n_plus=(node)
	do
		_n_plus = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_plus)
		v.enter_visit(_n_expr)
	end
end
redef class ANewExpr
	init init_anewexpr (
		n_kwnew: nullable TKwnew,
		n_type: nullable AType,
		n_id: nullable TId,
		n_args: nullable AExprs
	)
	do
		_n_kwnew = n_kwnew.as(not null)
		n_kwnew.parent = self
		_n_type = n_type.as(not null)
		n_type.parent = self
		_n_id = n_id
		if n_id != null then n_id.parent = self
		_n_args = n_args.as(not null)
		n_args.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwnew == old_child then
			n_kwnew = new_child.as(TKwnew)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(nullable TId)
			return
		end
		if _n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
	end

	redef fun n_kwnew=(node)
	do
		_n_kwnew = node
		node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		if node != null then node.parent = self
	end
	redef fun n_args=(node)
	do
		_n_args = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwnew)
		v.enter_visit(_n_type)
		v.enter_visit(_n_id)
		v.enter_visit(_n_args)
	end
end
redef class AAttrExpr
	init init_aattrexpr (
		n_expr: nullable AExpr,
		n_id: nullable TAttrid
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(TAttrid)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_id)
	end
end
redef class AAttrAssignExpr
	init init_aattrassignexpr (
		n_expr: nullable AExpr,
		n_id: nullable TAttrid,
		n_assign: nullable TAssign,
		n_value: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_assign = n_assign.as(not null)
		n_assign.parent = self
		_n_value = n_value.as(not null)
		n_value.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(TAttrid)
			return
		end
		if _n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
		if _n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		_n_assign = node
		node.parent = self
	end
	redef fun n_value=(node)
	do
		_n_value = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_id)
		v.enter_visit(_n_assign)
		v.enter_visit(_n_value)
	end
end
redef class AAttrReassignExpr
	init init_aattrreassignexpr (
		n_expr: nullable AExpr,
		n_id: nullable TAttrid,
		n_assign_op: nullable AAssignOp,
		n_value: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_assign_op = n_assign_op.as(not null)
		n_assign_op.parent = self
		_n_value = n_value.as(not null)
		n_value.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(TAttrid)
			return
		end
		if _n_assign_op == old_child then
			n_assign_op = new_child.as(AAssignOp)
			return
		end
		if _n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_assign_op=(node)
	do
		_n_assign_op = node
		node.parent = self
	end
	redef fun n_value=(node)
	do
		_n_value = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_id)
		v.enter_visit(_n_assign_op)
		v.enter_visit(_n_value)
	end
end
redef class ACallExpr
	init init_acallexpr (
		n_expr: nullable AExpr,
		n_id: nullable TId,
		n_args: nullable AExprs
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_args = n_args.as(not null)
		n_args.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if _n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_args=(node)
	do
		_n_args = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_id)
		v.enter_visit(_n_args)
	end
end
redef class ACallAssignExpr
	init init_acallassignexpr (
		n_expr: nullable AExpr,
		n_id: nullable TId,
		n_args: nullable AExprs,
		n_assign: nullable TAssign,
		n_value: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_args = n_args.as(not null)
		n_args.parent = self
		_n_assign = n_assign.as(not null)
		n_assign.parent = self
		_n_value = n_value.as(not null)
		n_value.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if _n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
		if _n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
		if _n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_args=(node)
	do
		_n_args = node
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		_n_assign = node
		node.parent = self
	end
	redef fun n_value=(node)
	do
		_n_value = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_id)
		v.enter_visit(_n_args)
		v.enter_visit(_n_assign)
		v.enter_visit(_n_value)
	end
end
redef class ACallReassignExpr
	init init_acallreassignexpr (
		n_expr: nullable AExpr,
		n_id: nullable TId,
		n_args: nullable AExprs,
		n_assign_op: nullable AAssignOp,
		n_value: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_args = n_args.as(not null)
		n_args.parent = self
		_n_assign_op = n_assign_op.as(not null)
		n_assign_op.parent = self
		_n_value = n_value.as(not null)
		n_value.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if _n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
		if _n_assign_op == old_child then
			n_assign_op = new_child.as(AAssignOp)
			return
		end
		if _n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_args=(node)
	do
		_n_args = node
		node.parent = self
	end
	redef fun n_assign_op=(node)
	do
		_n_assign_op = node
		node.parent = self
	end
	redef fun n_value=(node)
	do
		_n_value = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_id)
		v.enter_visit(_n_args)
		v.enter_visit(_n_assign_op)
		v.enter_visit(_n_value)
	end
end
redef class ASuperExpr
	init init_asuperexpr (
		n_qualified: nullable AQualified,
		n_kwsuper: nullable TKwsuper,
		n_args: nullable AExprs
	)
	do
		_n_qualified = n_qualified
		if n_qualified != null then n_qualified.parent = self
		_n_kwsuper = n_kwsuper.as(not null)
		n_kwsuper.parent = self
		_n_args = n_args.as(not null)
		n_args.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_qualified == old_child then
			n_qualified = new_child.as(nullable AQualified)
			return
		end
		if _n_kwsuper == old_child then
			n_kwsuper = new_child.as(TKwsuper)
			return
		end
		if _n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
	end

	redef fun n_qualified=(node)
	do
		_n_qualified = node
		if node != null then node.parent = self
	end
	redef fun n_kwsuper=(node)
	do
		_n_kwsuper = node
		node.parent = self
	end
	redef fun n_args=(node)
	do
		_n_args = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_qualified)
		v.enter_visit(_n_kwsuper)
		v.enter_visit(_n_args)
	end
end
redef class AInitExpr
	init init_ainitexpr (
		n_expr: nullable AExpr,
		n_kwinit: nullable TKwinit,
		n_args: nullable AExprs
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_kwinit = n_kwinit.as(not null)
		n_kwinit.parent = self
		_n_args = n_args.as(not null)
		n_args.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_kwinit == old_child then
			n_kwinit = new_child.as(TKwinit)
			return
		end
		if _n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_kwinit=(node)
	do
		_n_kwinit = node
		node.parent = self
	end
	redef fun n_args=(node)
	do
		_n_args = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_kwinit)
		v.enter_visit(_n_args)
	end
end
redef class ABraExpr
	init init_abraexpr (
		n_expr: nullable AExpr,
		n_args: nullable AExprs
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_args = n_args.as(not null)
		n_args.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_args=(node)
	do
		_n_args = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_args)
	end
end
redef class ABraAssignExpr
	init init_abraassignexpr (
		n_expr: nullable AExpr,
		n_args: nullable AExprs,
		n_assign: nullable TAssign,
		n_value: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_args = n_args.as(not null)
		n_args.parent = self
		_n_assign = n_assign.as(not null)
		n_assign.parent = self
		_n_value = n_value.as(not null)
		n_value.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
		if _n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
		if _n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_args=(node)
	do
		_n_args = node
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		_n_assign = node
		node.parent = self
	end
	redef fun n_value=(node)
	do
		_n_value = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_args)
		v.enter_visit(_n_assign)
		v.enter_visit(_n_value)
	end
end
redef class ABraReassignExpr
	init init_abrareassignexpr (
		n_expr: nullable AExpr,
		n_args: nullable AExprs,
		n_assign_op: nullable AAssignOp,
		n_value: nullable AExpr
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_args = n_args.as(not null)
		n_args.parent = self
		_n_assign_op = n_assign_op.as(not null)
		n_assign_op.parent = self
		_n_value = n_value.as(not null)
		n_value.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
		if _n_assign_op == old_child then
			n_assign_op = new_child.as(AAssignOp)
			return
		end
		if _n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_args=(node)
	do
		_n_args = node
		node.parent = self
	end
	redef fun n_assign_op=(node)
	do
		_n_assign_op = node
		node.parent = self
	end
	redef fun n_value=(node)
	do
		_n_value = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_args)
		v.enter_visit(_n_assign_op)
		v.enter_visit(_n_value)
	end
end
redef class AVarExpr
	init init_avarexpr (
		n_id: nullable TId
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
	end
end
redef class AVarAssignExpr
	init init_avarassignexpr (
		n_id: nullable TId,
		n_assign: nullable TAssign,
		n_value: nullable AExpr
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_assign = n_assign.as(not null)
		n_assign.parent = self
		_n_value = n_value.as(not null)
		n_value.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if _n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
		if _n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		_n_assign = node
		node.parent = self
	end
	redef fun n_value=(node)
	do
		_n_value = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
		v.enter_visit(_n_assign)
		v.enter_visit(_n_value)
	end
end
redef class AVarReassignExpr
	init init_avarreassignexpr (
		n_id: nullable TId,
		n_assign_op: nullable AAssignOp,
		n_value: nullable AExpr
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
		_n_assign_op = n_assign_op.as(not null)
		n_assign_op.parent = self
		_n_value = n_value.as(not null)
		n_value.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if _n_assign_op == old_child then
			n_assign_op = new_child.as(AAssignOp)
			return
		end
		if _n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end
	redef fun n_assign_op=(node)
	do
		_n_assign_op = node
		node.parent = self
	end
	redef fun n_value=(node)
	do
		_n_value = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
		v.enter_visit(_n_assign_op)
		v.enter_visit(_n_value)
	end
end
redef class ARangeExpr
	init init_arangeexpr (
		n_expr: nullable AExpr,
		n_expr2: nullable AExpr,
		n_annotations: nullable AAnnotations
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_expr2)
		v.enter_visit(_n_annotations)
	end
end
redef class ACrangeExpr
	init init_acrangeexpr (
		n_obra: nullable TObra,
		n_expr: nullable AExpr,
		n_expr2: nullable AExpr,
		n_cbra: nullable TCbra,
		n_annotations: nullable AAnnotations
	)
	do
		_n_obra = n_obra.as(not null)
		n_obra.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
		_n_cbra = n_cbra.as(not null)
		n_cbra.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
		if _n_cbra == old_child then
			n_cbra = new_child.as(TCbra)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_obra=(node)
	do
		_n_obra = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end
	redef fun n_cbra=(node)
	do
		_n_cbra = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_obra)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_expr2)
		v.enter_visit(_n_cbra)
		v.enter_visit(_n_annotations)
	end
end
redef class AOrangeExpr
	init init_aorangeexpr (
		n_obra: nullable TObra,
		n_expr: nullable AExpr,
		n_expr2: nullable AExpr,
		n_cbra: nullable TObra,
		n_annotations: nullable AAnnotations
	)
	do
		_n_obra = n_obra.as(not null)
		n_obra.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_expr2 = n_expr2.as(not null)
		n_expr2.parent = self
		_n_cbra = n_cbra.as(not null)
		n_cbra.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
		if _n_cbra == old_child then
			n_cbra = new_child.as(TObra)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_obra=(node)
	do
		_n_obra = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		_n_expr2 = node
		node.parent = self
	end
	redef fun n_cbra=(node)
	do
		_n_cbra = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_obra)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_expr2)
		v.enter_visit(_n_cbra)
		v.enter_visit(_n_annotations)
	end
end
redef class AArrayExpr
	init init_aarrayexpr (
		n_obra: nullable TObra,
		n_exprs: Collection[Object], # Should be Collection[AExpr]
		n_type: nullable AType,
		n_cbra: nullable TCbra,
		n_annotations: nullable AAnnotations
	)
	do
		_n_obra = n_obra.as(not null)
		n_obra.parent = self
		self.n_exprs.unsafe_add_all(n_exprs)
		_n_type = n_type
		if n_type != null then n_type.parent = self
		_n_cbra = n_cbra.as(not null)
		n_cbra.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if n_exprs.replace_child(old_child, new_child) then return
		if _n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
		if _n_cbra == old_child then
			n_cbra = new_child.as(TCbra)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_obra=(node)
	do
		_n_obra = node
		node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		if node != null then node.parent = self
	end
	redef fun n_cbra=(node)
	do
		_n_cbra = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_obra)
		n_exprs.visit_all(v)
		v.enter_visit(_n_type)
		v.enter_visit(_n_cbra)
		v.enter_visit(_n_annotations)
	end
end
redef class ASelfExpr
	init init_aselfexpr (
		n_kwself: nullable TKwself,
		n_annotations: nullable AAnnotations
	)
	do
		_n_kwself = n_kwself.as(not null)
		n_kwself.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwself == old_child then
			n_kwself = new_child.as(TKwself)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwself=(node)
	do
		_n_kwself = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwself)
		v.enter_visit(_n_annotations)
	end
end
redef class AImplicitSelfExpr
	init init_aimplicitselfexpr
	do
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
	end



	redef fun visit_all(v: Visitor)
	do
	end
end
redef class ATrueExpr
	init init_atrueexpr (
		n_kwtrue: nullable TKwtrue,
		n_annotations: nullable AAnnotations
	)
	do
		_n_kwtrue = n_kwtrue.as(not null)
		n_kwtrue.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwtrue == old_child then
			n_kwtrue = new_child.as(TKwtrue)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwtrue=(node)
	do
		_n_kwtrue = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwtrue)
		v.enter_visit(_n_annotations)
	end
end
redef class AFalseExpr
	init init_afalseexpr (
		n_kwfalse: nullable TKwfalse,
		n_annotations: nullable AAnnotations
	)
	do
		_n_kwfalse = n_kwfalse.as(not null)
		n_kwfalse.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwfalse == old_child then
			n_kwfalse = new_child.as(TKwfalse)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwfalse=(node)
	do
		_n_kwfalse = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwfalse)
		v.enter_visit(_n_annotations)
	end
end
redef class ANullExpr
	init init_anullexpr (
		n_kwnull: nullable TKwnull,
		n_annotations: nullable AAnnotations
	)
	do
		_n_kwnull = n_kwnull.as(not null)
		n_kwnull.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwnull == old_child then
			n_kwnull = new_child.as(TKwnull)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwnull=(node)
	do
		_n_kwnull = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwnull)
		v.enter_visit(_n_annotations)
	end
end
redef class ADecIntExpr
	init init_adecintexpr (
		n_number: nullable TNumber,
		n_annotations: nullable AAnnotations
	)
	do
		_n_number = n_number.as(not null)
		n_number.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_number == old_child then
			n_number = new_child.as(TNumber)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_number=(node)
	do
		_n_number = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_number)
		v.enter_visit(_n_annotations)
	end
end
redef class AHexIntExpr
	init init_ahexintexpr (
		n_hex_number: nullable THexNumber,
		n_annotations: nullable AAnnotations
	)
	do
		_n_hex_number = n_hex_number.as(not null)
		n_hex_number.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_hex_number == old_child then
			n_hex_number = new_child.as(THexNumber)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_hex_number=(node)
	do
		_n_hex_number = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_hex_number)
		v.enter_visit(_n_annotations)
	end
end
redef class AFloatExpr
	init init_afloatexpr (
		n_float: nullable TFloat,
		n_annotations: nullable AAnnotations
	)
	do
		_n_float = n_float.as(not null)
		n_float.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_float == old_child then
			n_float = new_child.as(TFloat)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_float=(node)
	do
		_n_float = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_float)
		v.enter_visit(_n_annotations)
	end
end
redef class ACharExpr
	init init_acharexpr (
		n_char: nullable TChar,
		n_annotations: nullable AAnnotations
	)
	do
		_n_char = n_char.as(not null)
		n_char.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_char == old_child then
			n_char = new_child.as(TChar)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_char=(node)
	do
		_n_char = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_char)
		v.enter_visit(_n_annotations)
	end
end
redef class AStringExpr
	init init_astringexpr (
		n_string: nullable TString,
		n_annotations: nullable AAnnotations
	)
	do
		_n_string = n_string.as(not null)
		n_string.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_string == old_child then
			n_string = new_child.as(TString)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_string=(node)
	do
		_n_string = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_string)
		v.enter_visit(_n_annotations)
	end
end
redef class AStartStringExpr
	init init_astartstringexpr (
		n_string: nullable TStartString
	)
	do
		_n_string = n_string.as(not null)
		n_string.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_string == old_child then
			n_string = new_child.as(TStartString)
			return
		end
	end

	redef fun n_string=(node)
	do
		_n_string = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_string)
	end
end
redef class AMidStringExpr
	init init_amidstringexpr (
		n_string: nullable TMidString
	)
	do
		_n_string = n_string.as(not null)
		n_string.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_string == old_child then
			n_string = new_child.as(TMidString)
			return
		end
	end

	redef fun n_string=(node)
	do
		_n_string = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_string)
	end
end
redef class AEndStringExpr
	init init_aendstringexpr (
		n_string: nullable TEndString
	)
	do
		_n_string = n_string.as(not null)
		n_string.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_string == old_child then
			n_string = new_child.as(TEndString)
			return
		end
	end

	redef fun n_string=(node)
	do
		_n_string = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_string)
	end
end
redef class ASuperstringExpr
	init init_asuperstringexpr (
		n_exprs: Collection[Object], # Should be Collection[AExpr]
		n_annotations: nullable AAnnotations
	)
	do
		self.n_exprs.unsafe_add_all(n_exprs)
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_exprs.replace_child(old_child, new_child) then return
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		n_exprs.visit_all(v)
		v.enter_visit(_n_annotations)
	end
end
redef class AParExpr
	init init_aparexpr (
		n_opar: nullable TOpar,
		n_expr: nullable AExpr,
		n_cpar: nullable TCpar,
		n_annotations: nullable AAnnotations
	)
	do
		_n_opar = n_opar.as(not null)
		n_opar.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_cpar = n_cpar.as(not null)
		n_cpar.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_opar == old_child then
			n_opar = new_child.as(TOpar)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_cpar == old_child then
			n_cpar = new_child.as(TCpar)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_opar=(node)
	do
		_n_opar = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_cpar=(node)
	do
		_n_cpar = node
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_opar)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_cpar)
		v.enter_visit(_n_annotations)
	end
end
redef class AAsCastExpr
	init init_aascastexpr (
		n_expr: nullable AExpr,
		n_kwas: nullable TKwas,
		n_opar: nullable TOpar,
		n_type: nullable AType,
		n_cpar: nullable TCpar
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_kwas = n_kwas.as(not null)
		n_kwas.parent = self
		_n_opar = n_opar
		if n_opar != null then n_opar.parent = self
		_n_type = n_type.as(not null)
		n_type.parent = self
		_n_cpar = n_cpar
		if n_cpar != null then n_cpar.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_kwas == old_child then
			n_kwas = new_child.as(TKwas)
			return
		end
		if _n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if _n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_kwas=(node)
	do
		_n_kwas = node
		node.parent = self
	end
	redef fun n_opar=(node)
	do
		_n_opar = node
		if node != null then node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end
	redef fun n_cpar=(node)
	do
		_n_cpar = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_kwas)
		v.enter_visit(_n_opar)
		v.enter_visit(_n_type)
		v.enter_visit(_n_cpar)
	end
end
redef class AAsNotnullExpr
	init init_aasnotnullexpr (
		n_expr: nullable AExpr,
		n_kwas: nullable TKwas,
		n_opar: nullable TOpar,
		n_kwnot: nullable TKwnot,
		n_kwnull: nullable TKwnull,
		n_cpar: nullable TCpar
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_kwas = n_kwas.as(not null)
		n_kwas.parent = self
		_n_opar = n_opar
		if n_opar != null then n_opar.parent = self
		_n_kwnot = n_kwnot.as(not null)
		n_kwnot.parent = self
		_n_kwnull = n_kwnull.as(not null)
		n_kwnull.parent = self
		_n_cpar = n_cpar
		if n_cpar != null then n_cpar.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_kwas == old_child then
			n_kwas = new_child.as(TKwas)
			return
		end
		if _n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if _n_kwnot == old_child then
			n_kwnot = new_child.as(TKwnot)
			return
		end
		if _n_kwnull == old_child then
			n_kwnull = new_child.as(TKwnull)
			return
		end
		if _n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_kwas=(node)
	do
		_n_kwas = node
		node.parent = self
	end
	redef fun n_opar=(node)
	do
		_n_opar = node
		if node != null then node.parent = self
	end
	redef fun n_kwnot=(node)
	do
		_n_kwnot = node
		node.parent = self
	end
	redef fun n_kwnull=(node)
	do
		_n_kwnull = node
		node.parent = self
	end
	redef fun n_cpar=(node)
	do
		_n_cpar = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_kwas)
		v.enter_visit(_n_opar)
		v.enter_visit(_n_kwnot)
		v.enter_visit(_n_kwnull)
		v.enter_visit(_n_cpar)
	end
end
redef class AIssetAttrExpr
	init init_aissetattrexpr (
		n_kwisset: nullable TKwisset,
		n_expr: nullable AExpr,
		n_id: nullable TAttrid
	)
	do
		_n_kwisset = n_kwisset.as(not null)
		n_kwisset.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwisset == old_child then
			n_kwisset = new_child.as(TKwisset)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(TAttrid)
			return
		end
	end

	redef fun n_kwisset=(node)
	do
		_n_kwisset = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwisset)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_id)
	end
end
redef class ADebugTypeExpr
	init init_adebugtypeexpr (
		n_kwdebug: nullable TKwdebug,
		n_kwtype: nullable TKwtype,
		n_expr: nullable AExpr,
		n_type: nullable AType
	)
	do
		_n_kwdebug = n_kwdebug.as(not null)
		n_kwdebug.parent = self
		_n_kwtype = n_kwtype.as(not null)
		n_kwtype.parent = self
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_type = n_type.as(not null)
		n_type.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwdebug == old_child then
			n_kwdebug = new_child.as(TKwdebug)
			return
		end
		if _n_kwtype == old_child then
			n_kwtype = new_child.as(TKwtype)
			return
		end
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
	end

	redef fun n_kwdebug=(node)
	do
		_n_kwdebug = node
		node.parent = self
	end
	redef fun n_kwtype=(node)
	do
		_n_kwtype = node
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwdebug)
		v.enter_visit(_n_kwtype)
		v.enter_visit(_n_expr)
		v.enter_visit(_n_type)
	end
end
redef class AVarargExpr
	init init_avarargexpr (
		n_expr: nullable AExpr,
		n_dotdotdot: nullable TDotdotdot
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_dotdotdot = n_dotdotdot.as(not null)
		n_dotdotdot.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_dotdotdot == old_child then
			n_dotdotdot = new_child.as(TDotdotdot)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_dotdotdot=(node)
	do
		_n_dotdotdot = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_dotdotdot)
	end
end
redef class ASafeExpr
	init init_asafeexpr (
		n_expr: nullable AExpr,
		n_quest: nullable TQuest
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_quest = n_quest.as(not null)
		n_quest.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_quest == old_child then
			n_quest = new_child.as(TQuest)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_quest=(node)
	do
		_n_quest = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_quest)
	end
end
redef class ATypeExpr
	init init_atypeexpr (
		n_type: nullable AType
	)
	do
		_n_type = n_type.as(not null)
		n_type.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
	end

	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_type)
	end
end
redef class AMethidExpr
	init init_amethidexpr (
		n_expr: nullable AExpr,
		n_id: nullable AMethid
	)
	do
		_n_expr = n_expr.as(not null)
		n_expr.parent = self
		_n_id = n_id.as(not null)
		n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if _n_id == old_child then
			n_id = new_child.as(AMethid)
			return
		end
	end

	redef fun n_expr=(node)
	do
		_n_expr = node
		node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_expr)
		v.enter_visit(_n_id)
	end
end
redef class AAtExpr
	init init_aatexpr (
		n_annotations: nullable AAnnotations
	)
	do
		_n_annotations = n_annotations.as(not null)
		n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_annotations == old_child then
			n_annotations = new_child.as(AAnnotations)
			return
		end
	end

	redef fun n_annotations=(node)
	do
		_n_annotations = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_annotations)
	end
end
redef class AManyExpr
	init init_amanyexpr (
		n_exprs: Collection[Object] # Should be Collection[AExpr]
	)
	do
		self.n_exprs.unsafe_add_all(n_exprs)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_exprs.replace_child(old_child, new_child) then return
	end



	redef fun visit_all(v: Visitor)
	do
		n_exprs.visit_all(v)
	end
end
redef class AListExprs
	init init_alistexprs (
		n_exprs: Collection[Object] # Should be Collection[AExpr]
	)
	do
		self.n_exprs.unsafe_add_all(n_exprs)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_exprs.replace_child(old_child, new_child) then return
	end



	redef fun visit_all(v: Visitor)
	do
		n_exprs.visit_all(v)
	end
end
redef class AParExprs
	init init_aparexprs (
		n_opar: nullable TOpar,
		n_exprs: Collection[Object], # Should be Collection[AExpr]
		n_cpar: nullable TCpar
	)
	do
		_n_opar = n_opar.as(not null)
		n_opar.parent = self
		self.n_exprs.unsafe_add_all(n_exprs)
		_n_cpar = n_cpar.as(not null)
		n_cpar.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_opar == old_child then
			n_opar = new_child.as(TOpar)
			return
		end
		if n_exprs.replace_child(old_child, new_child) then return
		if _n_cpar == old_child then
			n_cpar = new_child.as(TCpar)
			return
		end
	end

	redef fun n_opar=(node)
	do
		_n_opar = node
		node.parent = self
	end
	redef fun n_cpar=(node)
	do
		_n_cpar = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_opar)
		n_exprs.visit_all(v)
		v.enter_visit(_n_cpar)
	end
end
redef class ABraExprs
	init init_abraexprs (
		n_obra: nullable TObra,
		n_exprs: Collection[Object], # Should be Collection[AExpr]
		n_cbra: nullable TCbra
	)
	do
		_n_obra = n_obra.as(not null)
		n_obra.parent = self
		self.n_exprs.unsafe_add_all(n_exprs)
		_n_cbra = n_cbra.as(not null)
		n_cbra.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if n_exprs.replace_child(old_child, new_child) then return
		if _n_cbra == old_child then
			n_cbra = new_child.as(TCbra)
			return
		end
	end

	redef fun n_obra=(node)
	do
		_n_obra = node
		node.parent = self
	end
	redef fun n_cbra=(node)
	do
		_n_cbra = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_obra)
		n_exprs.visit_all(v)
		v.enter_visit(_n_cbra)
	end
end
redef class APlusAssignOp
	init init_aplusassignop (
		n_op: nullable TPluseq
	)
	do
		_n_op = n_op.as(not null)
		n_op.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_op == old_child then
			n_op = new_child.as(TPluseq)
			return
		end
	end

	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_op)
	end
end
redef class AMinusAssignOp
	init init_aminusassignop (
		n_op: nullable TMinuseq
	)
	do
		_n_op = n_op.as(not null)
		n_op.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_op == old_child then
			n_op = new_child.as(TMinuseq)
			return
		end
	end

	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_op)
	end
end
redef class AStarAssignOp
	init init_astarassignop (
		n_op: nullable TStareq
	)
	do
		_n_op = n_op.as(not null)
		n_op.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_op == old_child then
			n_op = new_child.as(TStareq)
			return
		end
	end

	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_op)
	end
end
redef class ASlashAssignOp
	init init_aslashassignop (
		n_op: nullable TSlasheq
	)
	do
		_n_op = n_op.as(not null)
		n_op.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_op == old_child then
			n_op = new_child.as(TSlasheq)
			return
		end
	end

	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_op)
	end
end
redef class APercentAssignOp
	init init_apercentassignop (
		n_op: nullable TPercenteq
	)
	do
		_n_op = n_op.as(not null)
		n_op.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_op == old_child then
			n_op = new_child.as(TPercenteq)
			return
		end
	end

	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_op)
	end
end
redef class AStarstarAssignOp
	init init_astarstarassignop (
		n_op: nullable TStarstareq
	)
	do
		_n_op = n_op.as(not null)
		n_op.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_op == old_child then
			n_op = new_child.as(TStarstareq)
			return
		end
	end

	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_op)
	end
end
redef class ALlAssignOp
	init init_allassignop (
		n_op: nullable TLleq
	)
	do
		_n_op = n_op.as(not null)
		n_op.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_op == old_child then
			n_op = new_child.as(TLleq)
			return
		end
	end

	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_op)
	end
end
redef class AGgAssignOp
	init init_aggassignop (
		n_op: nullable TGgeq
	)
	do
		_n_op = n_op.as(not null)
		n_op.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_op == old_child then
			n_op = new_child.as(TGgeq)
			return
		end
	end

	redef fun n_op=(node)
	do
		_n_op = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_op)
	end
end
redef class AModuleName
	init init_amodulename (
		n_quad: nullable TQuad,
		n_path: Collection[Object], # Should be Collection[TId]
		n_id: nullable TId
	)
	do
		_n_quad = n_quad
		if n_quad != null then n_quad.parent = self
		self.n_path.unsafe_add_all(n_path)
		_n_id = n_id.as(not null)
		n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_quad == old_child then
			n_quad = new_child.as(nullable TQuad)
			return
		end
		if n_path.replace_child(old_child, new_child) then return
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
	end

	redef fun n_quad=(node)
	do
		_n_quad = node
		if node != null then node.parent = self
	end
	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_quad)
		n_path.visit_all(v)
		v.enter_visit(_n_id)
	end
end
redef class AExternCalls
	init init_aexterncalls (
		n_kwimport: nullable TKwimport,
		n_extern_calls: Collection[Object] # Should be Collection[AExternCall]
	)
	do
		_n_kwimport = n_kwimport.as(not null)
		n_kwimport.parent = self
		self.n_extern_calls.unsafe_add_all(n_extern_calls)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwimport == old_child then
			n_kwimport = new_child.as(TKwimport)
			return
		end
		if n_extern_calls.replace_child(old_child, new_child) then return
	end

	redef fun n_kwimport=(node)
	do
		_n_kwimport = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwimport)
		n_extern_calls.visit_all(v)
	end
end
redef class AExternCall
	init init_aexterncall
	do
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
	end



	redef fun visit_all(v: Visitor)
	do
	end
end
redef class ASuperExternCall
	init init_asuperexterncall (
		n_kwsuper: nullable TKwsuper
	)
	do
		_n_kwsuper = n_kwsuper.as(not null)
		n_kwsuper.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwsuper == old_child then
			n_kwsuper = new_child.as(TKwsuper)
			return
		end
	end

	redef fun n_kwsuper=(node)
	do
		_n_kwsuper = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwsuper)
	end
end
redef class ALocalPropExternCall
	init init_alocalpropexterncall (
		n_methid: nullable AMethid
	)
	do
		_n_methid = n_methid.as(not null)
		n_methid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_methid == old_child then
			n_methid = new_child.as(AMethid)
			return
		end
	end

	redef fun n_methid=(node)
	do
		_n_methid = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_methid)
	end
end
redef class AFullPropExternCall
	init init_afullpropexterncall (
		n_type: nullable AType,
		n_dot: nullable TDot,
		n_methid: nullable AMethid
	)
	do
		_n_type = n_type.as(not null)
		n_type.parent = self
		_n_dot = n_dot
		if n_dot != null then n_dot.parent = self
		_n_methid = n_methid.as(not null)
		n_methid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if _n_dot == old_child then
			n_dot = new_child.as(nullable TDot)
			return
		end
		if _n_methid == old_child then
			n_methid = new_child.as(AMethid)
			return
		end
	end

	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end
	redef fun n_dot=(node)
	do
		_n_dot = node
		if node != null then node.parent = self
	end
	redef fun n_methid=(node)
	do
		_n_methid = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_type)
		v.enter_visit(_n_dot)
		v.enter_visit(_n_methid)
	end
end
redef class AInitPropExternCall
	init init_ainitpropexterncall (
		n_type: nullable AType
	)
	do
		_n_type = n_type.as(not null)
		n_type.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
	end

	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_type)
	end
end
redef class ACastAsExternCall
	init init_acastasexterncall (
		n_from_type: nullable AType,
		n_dot: nullable TDot,
		n_kwas: nullable TKwas,
		n_to_type: nullable AType
	)
	do
		_n_from_type = n_from_type.as(not null)
		n_from_type.parent = self
		_n_dot = n_dot
		if n_dot != null then n_dot.parent = self
		_n_kwas = n_kwas.as(not null)
		n_kwas.parent = self
		_n_to_type = n_to_type.as(not null)
		n_to_type.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_from_type == old_child then
			n_from_type = new_child.as(AType)
			return
		end
		if _n_dot == old_child then
			n_dot = new_child.as(nullable TDot)
			return
		end
		if _n_kwas == old_child then
			n_kwas = new_child.as(TKwas)
			return
		end
		if _n_to_type == old_child then
			n_to_type = new_child.as(AType)
			return
		end
	end

	redef fun n_from_type=(node)
	do
		_n_from_type = node
		node.parent = self
	end
	redef fun n_dot=(node)
	do
		_n_dot = node
		if node != null then node.parent = self
	end
	redef fun n_kwas=(node)
	do
		_n_kwas = node
		node.parent = self
	end
	redef fun n_to_type=(node)
	do
		_n_to_type = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_from_type)
		v.enter_visit(_n_dot)
		v.enter_visit(_n_kwas)
		v.enter_visit(_n_to_type)
	end
end
redef class AAsNullableExternCall
	init init_aasnullableexterncall (
		n_type: nullable AType,
		n_kwas: nullable TKwas,
		n_kwnullable: nullable TKwnullable
	)
	do
		_n_type = n_type.as(not null)
		n_type.parent = self
		_n_kwas = n_kwas.as(not null)
		n_kwas.parent = self
		_n_kwnullable = n_kwnullable.as(not null)
		n_kwnullable.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if _n_kwas == old_child then
			n_kwas = new_child.as(TKwas)
			return
		end
		if _n_kwnullable == old_child then
			n_kwnullable = new_child.as(TKwnullable)
			return
		end
	end

	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end
	redef fun n_kwas=(node)
	do
		_n_kwas = node
		node.parent = self
	end
	redef fun n_kwnullable=(node)
	do
		_n_kwnullable = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_type)
		v.enter_visit(_n_kwas)
		v.enter_visit(_n_kwnullable)
	end
end
redef class AAsNotNullableExternCall
	init init_aasnotnullableexterncall (
		n_type: nullable AType,
		n_kwas: nullable TKwas,
		n_kwnot: nullable TKwnot,
		n_kwnullable: nullable TKwnullable
	)
	do
		_n_type = n_type.as(not null)
		n_type.parent = self
		_n_kwas = n_kwas.as(not null)
		n_kwas.parent = self
		_n_kwnot = n_kwnot.as(not null)
		n_kwnot.parent = self
		_n_kwnullable = n_kwnullable.as(not null)
		n_kwnullable.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if _n_kwas == old_child then
			n_kwas = new_child.as(TKwas)
			return
		end
		if _n_kwnot == old_child then
			n_kwnot = new_child.as(TKwnot)
			return
		end
		if _n_kwnullable == old_child then
			n_kwnullable = new_child.as(TKwnullable)
			return
		end
	end

	redef fun n_type=(node)
	do
		_n_type = node
		node.parent = self
	end
	redef fun n_kwas=(node)
	do
		_n_kwas = node
		node.parent = self
	end
	redef fun n_kwnot=(node)
	do
		_n_kwnot = node
		node.parent = self
	end
	redef fun n_kwnullable=(node)
	do
		_n_kwnullable = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_type)
		v.enter_visit(_n_kwas)
		v.enter_visit(_n_kwnot)
		v.enter_visit(_n_kwnullable)
	end
end
redef class AInLanguage
	init init_ainlanguage (
		n_kwin: nullable TKwin,
		n_string: nullable TString
	)
	do
		_n_kwin = n_kwin.as(not null)
		n_kwin.parent = self
		_n_string = n_string.as(not null)
		n_string.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_kwin == old_child then
			n_kwin = new_child.as(TKwin)
			return
		end
		if _n_string == old_child then
			n_string = new_child.as(TString)
			return
		end
	end

	redef fun n_kwin=(node)
	do
		_n_kwin = node
		node.parent = self
	end
	redef fun n_string=(node)
	do
		_n_string = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_kwin)
		v.enter_visit(_n_string)
	end
end
redef class AExternCodeBlock
	init init_aexterncodeblock (
		n_in_language: nullable AInLanguage,
		n_extern_code_segment: nullable TExternCodeSegment
	)
	do
		_n_in_language = n_in_language
		if n_in_language != null then n_in_language.parent = self
		_n_extern_code_segment = n_extern_code_segment.as(not null)
		n_extern_code_segment.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_in_language == old_child then
			n_in_language = new_child.as(nullable AInLanguage)
			return
		end
		if _n_extern_code_segment == old_child then
			n_extern_code_segment = new_child.as(TExternCodeSegment)
			return
		end
	end

	redef fun n_in_language=(node)
	do
		_n_in_language = node
		if node != null then node.parent = self
	end
	redef fun n_extern_code_segment=(node)
	do
		_n_extern_code_segment = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_in_language)
		v.enter_visit(_n_extern_code_segment)
	end
end
redef class AQualified
	init init_aqualified (
		n_id: Collection[Object], # Should be Collection[TId]
		n_classid: nullable TClassid
	)
	do
		self.n_id.unsafe_add_all(n_id)
		_n_classid = n_classid
		if n_classid != null then n_classid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id.replace_child(old_child, new_child) then return
		if _n_classid == old_child then
			n_classid = new_child.as(nullable TClassid)
			return
		end
	end

	redef fun n_classid=(node)
	do
		_n_classid = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		n_id.visit_all(v)
		v.enter_visit(_n_classid)
	end
end
redef class ADoc
	init init_adoc (
		n_comment: Collection[Object] # Should be Collection[TComment]
	)
	do
		self.n_comment.unsafe_add_all(n_comment)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_comment.replace_child(old_child, new_child) then return
	end



	redef fun visit_all(v: Visitor)
	do
		n_comment.visit_all(v)
	end
end
redef class AAnnotations
	init init_aannotations (
		n_at: nullable TAt,
		n_opar: nullable TOpar,
		n_items: Collection[Object], # Should be Collection[AAnnotation]
		n_cpar: nullable TCpar
	)
	do
		_n_at = n_at
		if n_at != null then n_at.parent = self
		_n_opar = n_opar
		if n_opar != null then n_opar.parent = self
		self.n_items.unsafe_add_all(n_items)
		_n_cpar = n_cpar
		if n_cpar != null then n_cpar.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_at == old_child then
			n_at = new_child.as(nullable TAt)
			return
		end
		if _n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if n_items.replace_child(old_child, new_child) then return
		if _n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
	end

	redef fun n_at=(node)
	do
		_n_at = node
		if node != null then node.parent = self
	end
	redef fun n_opar=(node)
	do
		_n_opar = node
		if node != null then node.parent = self
	end
	redef fun n_cpar=(node)
	do
		_n_cpar = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_at)
		v.enter_visit(_n_opar)
		n_items.visit_all(v)
		v.enter_visit(_n_cpar)
	end
end
redef class AAnnotation
	init init_aannotation (
		n_doc: nullable ADoc,
		n_kwredef: nullable TKwredef,
		n_visibility: nullable AVisibility,
		n_atid: nullable AAtid,
		n_opar: nullable TOpar,
		n_args: Collection[Object], # Should be Collection[AExpr]
		n_cpar: nullable TCpar,
		n_annotations: nullable AAnnotations
	)
	do
		_n_doc = n_doc
		if n_doc != null then n_doc.parent = self
		_n_kwredef = n_kwredef
		if n_kwredef != null then n_kwredef.parent = self
		_n_visibility = n_visibility
		if n_visibility != null then n_visibility.parent = self
		_n_atid = n_atid.as(not null)
		n_atid.parent = self
		_n_opar = n_opar
		if n_opar != null then n_opar.parent = self
		self.n_args.unsafe_add_all(n_args)
		_n_cpar = n_cpar
		if n_cpar != null then n_cpar.parent = self
		_n_annotations = n_annotations
		if n_annotations != null then n_annotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if _n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if _n_visibility == old_child then
			n_visibility = new_child.as(nullable AVisibility)
			return
		end
		if _n_atid == old_child then
			n_atid = new_child.as(AAtid)
			return
		end
		if _n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if n_args.replace_child(old_child, new_child) then return
		if _n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
		if _n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_doc=(node)
	do
		_n_doc = node
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		_n_kwredef = node
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		_n_visibility = node
		if node != null then node.parent = self
	end
	redef fun n_atid=(node)
	do
		_n_atid = node
		node.parent = self
	end
	redef fun n_opar=(node)
	do
		_n_opar = node
		if node != null then node.parent = self
	end
	redef fun n_cpar=(node)
	do
		_n_cpar = node
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		_n_annotations = node
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_doc)
		v.enter_visit(_n_kwredef)
		v.enter_visit(_n_visibility)
		v.enter_visit(_n_atid)
		v.enter_visit(_n_opar)
		n_args.visit_all(v)
		v.enter_visit(_n_cpar)
		v.enter_visit(_n_annotations)
	end
end
redef class AIdAtid
	init init_aidatid (
		n_id: nullable TId
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
	end
end
redef class AKwexternAtid
	init init_akwexternatid (
		n_id: nullable TKwextern
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TKwextern)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
	end
end
redef class AKwabstractAtid
	init init_akwabstractatid (
		n_id: nullable TKwabstract
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TKwabstract)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
	end
end
redef class AKwimportAtid
	init init_akwimportatid (
		n_id: nullable TKwimport
	)
	do
		_n_id = n_id.as(not null)
		n_id.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if _n_id == old_child then
			n_id = new_child.as(TKwimport)
			return
		end
	end

	redef fun n_id=(node)
	do
		_n_id = node
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(_n_id)
	end
end

redef class Start
    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if _n_base == old_child then
            if new_child == null then
            else
                new_child.parent = self
		assert new_child isa AModule
                _n_base = new_child
            end
            old_child.parent = null
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if _n_base != null then
            v.enter_visit(_n_base.as(not null))
        end
	v.enter_visit(_n_eof)
    end
end
