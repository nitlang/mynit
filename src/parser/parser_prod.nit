# Production AST nodes full definition.
# This file was generated by SableCC (http://www.sablecc.org/).
module parser_prod

import lexer
intrude import parser_nodes
private import tables

redef class AModule
	private init empty_init do end

	init init_amodule (
		nmoduledecl: nullable AModuledecl,
		nimports: Collection[Object], # Should be Collection[AImport]
		nextern_code_blocks: Collection[Object], # Should be Collection[AExternCodeBlock]
		nclassdefs: Collection[Object] # Should be Collection[AClassdef]
	)
	do
		empty_init
		n_moduledecl = nmoduledecl
		if nmoduledecl != null then nmoduledecl.parent = self
		n_imports.unsafe_add_all(nimports)
		n_extern_code_blocks.unsafe_add_all(nextern_code_blocks)
		n_classdefs.unsafe_add_all(nclassdefs)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_moduledecl == old_child then
			n_moduledecl = new_child.as(nullable AModuledecl)
			return
		end
		if n_imports.replace_child(old_child, new_child) then return
		if n_extern_code_blocks.replace_child(old_child, new_child) then return
		if n_classdefs.replace_child(old_child, new_child) then return
	end

	redef fun n_moduledecl=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_moduledecl)
		n_imports.visit_all(v)
		n_extern_code_blocks.visit_all(v)
		n_classdefs.visit_all(v)
	end
end
redef class AModuledecl
	private init empty_init do end

	init init_amoduledecl (
		ndoc: nullable ADoc,
		nkwmodule: nullable TKwmodule,
		nname: nullable AModuleName,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_kwmodule = nkwmodule.as(not null)
		nkwmodule.parent = self
		n_name = nname.as(not null)
		nname.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_kwmodule == old_child then
			n_kwmodule = new_child.as(TKwmodule)
			return
		end
		if n_name == old_child then
			n_name = new_child.as(AModuleName)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwmodule=(node)
	do
		super
		node.parent = self
	end
	redef fun n_name=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_kwmodule)
		v.enter_visit(n_name)
		v.enter_visit(n_annotations)
	end
end
redef class AStdImport
	private init empty_init do end

	init init_astdimport (
		nvisibility: nullable AVisibility,
		nkwimport: nullable TKwimport,
		nname: nullable AModuleName,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_kwimport = nkwimport.as(not null)
		nkwimport.parent = self
		n_name = nname.as(not null)
		nname.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_kwimport == old_child then
			n_kwimport = new_child.as(TKwimport)
			return
		end
		if n_name == old_child then
			n_name = new_child.as(AModuleName)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwimport=(node)
	do
		super
		node.parent = self
	end
	redef fun n_name=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwimport)
		v.enter_visit(n_name)
		v.enter_visit(n_annotations)
	end
end
redef class ANoImport
	private init empty_init do end

	init init_anoimport (
		nvisibility: nullable AVisibility,
		nkwimport: nullable TKwimport,
		nkwend: nullable TKwend
	)
	do
		empty_init
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_kwimport = nkwimport.as(not null)
		nkwimport.parent = self
		n_kwend = nkwend.as(not null)
		nkwend.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_kwimport == old_child then
			n_kwimport = new_child.as(TKwimport)
			return
		end
		if n_kwend == old_child then
			n_kwend = new_child.as(TKwend)
			return
		end
	end

	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwimport=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwend=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwimport)
		v.enter_visit(n_kwend)
	end
end
redef class APublicVisibility
	private init empty_init do end

	init init_apublicvisibility
	do
		empty_init
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
	end



	redef fun visit_all(v: Visitor)
	do
	end
end
redef class APrivateVisibility
	private init empty_init do end

	init init_aprivatevisibility (
		nkwprivate: nullable TKwprivate
	)
	do
		empty_init
		n_kwprivate = nkwprivate.as(not null)
		nkwprivate.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwprivate == old_child then
			n_kwprivate = new_child.as(TKwprivate)
			return
		end
	end

	redef fun n_kwprivate=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwprivate)
	end
end
redef class AProtectedVisibility
	private init empty_init do end

	init init_aprotectedvisibility (
		nkwprotected: nullable TKwprotected
	)
	do
		empty_init
		n_kwprotected = nkwprotected.as(not null)
		nkwprotected.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwprotected == old_child then
			n_kwprotected = new_child.as(TKwprotected)
			return
		end
	end

	redef fun n_kwprotected=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwprotected)
	end
end
redef class AIntrudeVisibility
	private init empty_init do end

	init init_aintrudevisibility (
		nkwintrude: nullable TKwintrude
	)
	do
		empty_init
		n_kwintrude = nkwintrude.as(not null)
		nkwintrude.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwintrude == old_child then
			n_kwintrude = new_child.as(TKwintrude)
			return
		end
	end

	redef fun n_kwintrude=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwintrude)
	end
end
redef class AStdClassdef
	private init empty_init do end

	init init_astdclassdef (
		ndoc: nullable ADoc,
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nclasskind: nullable AClasskind,
		nid: nullable TClassid,
		nformaldefs: Collection[Object], # Should be Collection[AFormaldef]
		nannotations: nullable AAnnotations,
		nextern_code_block: nullable AExternCodeBlock,
		nsuperclasses: Collection[Object], # Should be Collection[ASuperclass]
		npropdefs: Collection[Object], # Should be Collection[APropdef]
		nkwend: nullable TKwend
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_classkind = nclasskind.as(not null)
		nclasskind.parent = self
		n_id = nid
		if nid != null then nid.parent = self
		n_formaldefs.unsafe_add_all(nformaldefs)
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
		n_extern_code_block = nextern_code_block
		if nextern_code_block != null then nextern_code_block.parent = self
		n_superclasses.unsafe_add_all(nsuperclasses)
		n_propdefs.unsafe_add_all(npropdefs)
		n_kwend = nkwend.as(not null)
		nkwend.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_classkind == old_child then
			n_classkind = new_child.as(AClasskind)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(nullable TClassid)
			return
		end
		if n_formaldefs.replace_child(old_child, new_child) then return
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
		if n_extern_code_block == old_child then
			n_extern_code_block = new_child.as(nullable AExternCodeBlock)
			return
		end
		if n_superclasses.replace_child(old_child, new_child) then return
		if n_propdefs.replace_child(old_child, new_child) then return
		if n_kwend == old_child then
			n_kwend = new_child.as(TKwend)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_classkind=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_extern_code_block=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwend=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_classkind)
		v.enter_visit(n_id)
		n_formaldefs.visit_all(v)
		v.enter_visit(n_annotations)
		v.enter_visit(n_extern_code_block)
		n_superclasses.visit_all(v)
		n_propdefs.visit_all(v)
		v.enter_visit(n_kwend)
	end
end
redef class ATopClassdef
	private init empty_init do end

	init init_atopclassdef (
		npropdefs: Collection[Object] # Should be Collection[APropdef]
	)
	do
		empty_init
		n_propdefs.unsafe_add_all(npropdefs)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_propdefs.replace_child(old_child, new_child) then return
	end



	redef fun visit_all(v: Visitor)
	do
		n_propdefs.visit_all(v)
	end
end
redef class AMainClassdef
	private init empty_init do end

	init init_amainclassdef (
		npropdefs: Collection[Object] # Should be Collection[APropdef]
	)
	do
		empty_init
		n_propdefs.unsafe_add_all(npropdefs)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_propdefs.replace_child(old_child, new_child) then return
	end



	redef fun visit_all(v: Visitor)
	do
		n_propdefs.visit_all(v)
	end
end
redef class AConcreteClasskind
	private init empty_init do end

	init init_aconcreteclasskind (
		nkwclass: nullable TKwclass
	)
	do
		empty_init
		n_kwclass = nkwclass.as(not null)
		nkwclass.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwclass == old_child then
			n_kwclass = new_child.as(TKwclass)
			return
		end
	end

	redef fun n_kwclass=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwclass)
	end
end
redef class AAbstractClasskind
	private init empty_init do end

	init init_aabstractclasskind (
		nkwabstract: nullable TKwabstract,
		nkwclass: nullable TKwclass
	)
	do
		empty_init
		n_kwabstract = nkwabstract.as(not null)
		nkwabstract.parent = self
		n_kwclass = nkwclass.as(not null)
		nkwclass.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwabstract == old_child then
			n_kwabstract = new_child.as(TKwabstract)
			return
		end
		if n_kwclass == old_child then
			n_kwclass = new_child.as(TKwclass)
			return
		end
	end

	redef fun n_kwabstract=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwclass=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwabstract)
		v.enter_visit(n_kwclass)
	end
end
redef class AInterfaceClasskind
	private init empty_init do end

	init init_ainterfaceclasskind (
		nkwinterface: nullable TKwinterface
	)
	do
		empty_init
		n_kwinterface = nkwinterface.as(not null)
		nkwinterface.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwinterface == old_child then
			n_kwinterface = new_child.as(TKwinterface)
			return
		end
	end

	redef fun n_kwinterface=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwinterface)
	end
end
redef class AEnumClasskind
	private init empty_init do end

	init init_aenumclasskind (
		nkwenum: nullable TKwenum
	)
	do
		empty_init
		n_kwenum = nkwenum.as(not null)
		nkwenum.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwenum == old_child then
			n_kwenum = new_child.as(TKwenum)
			return
		end
	end

	redef fun n_kwenum=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwenum)
	end
end
redef class AExternClasskind
	private init empty_init do end

	init init_aexternclasskind (
		nkwextern: nullable TKwextern,
		nkwclass: nullable TKwclass
	)
	do
		empty_init
		n_kwextern = nkwextern.as(not null)
		nkwextern.parent = self
		n_kwclass = nkwclass
		if nkwclass != null then nkwclass.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwextern == old_child then
			n_kwextern = new_child.as(TKwextern)
			return
		end
		if n_kwclass == old_child then
			n_kwclass = new_child.as(nullable TKwclass)
			return
		end
	end

	redef fun n_kwextern=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwclass=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwextern)
		v.enter_visit(n_kwclass)
	end
end
redef class AFormaldef
	private init empty_init do end

	init init_aformaldef (
		nid: nullable TClassid,
		ntype: nullable AType,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
		n_type = ntype
		if ntype != null then ntype.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TClassid)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
		v.enter_visit(n_type)
		v.enter_visit(n_annotations)
	end
end
redef class ASuperclass
	private init empty_init do end

	init init_asuperclass (
		nkwsuper: nullable TKwsuper,
		ntype: nullable AType,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_kwsuper = nkwsuper.as(not null)
		nkwsuper.parent = self
		n_type = ntype.as(not null)
		ntype.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwsuper == old_child then
			n_kwsuper = new_child.as(TKwsuper)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwsuper=(node)
	do
		super
		node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwsuper)
		v.enter_visit(n_type)
		v.enter_visit(n_annotations)
	end
end
redef class AAttrPropdef
	private init empty_init do end

	init init_aattrpropdef (
		ndoc: nullable ADoc,
		nreadable: nullable AAble,
		nwritable: nullable AAble,
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nkwvar: nullable TKwvar,
		nid: nullable TAttrid,
		nid2: nullable TId,
		ntype: nullable AType,
		nannotations: nullable AAnnotations,
		nexpr: nullable AExpr
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_readable = nreadable
		if nreadable != null then nreadable.parent = self
		n_writable = nwritable
		if nwritable != null then nwritable.parent = self
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_kwvar = nkwvar.as(not null)
		nkwvar.parent = self
		n_id = nid
		if nid != null then nid.parent = self
		n_id2 = nid2
		if nid2 != null then nid2.parent = self
		n_type = ntype
		if ntype != null then ntype.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
		n_expr = nexpr
		if nexpr != null then nexpr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_readable == old_child then
			n_readable = new_child.as(nullable AAble)
			return
		end
		if n_writable == old_child then
			n_writable = new_child.as(nullable AAble)
			return
		end
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_kwvar == old_child then
			n_kwvar = new_child.as(TKwvar)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(nullable TAttrid)
			return
		end
		if n_id2 == old_child then
			n_id2 = new_child.as(nullable TId)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_readable=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_writable=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwvar=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_id2=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_readable)
		v.enter_visit(n_writable)
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwvar)
		v.enter_visit(n_id)
		v.enter_visit(n_id2)
		v.enter_visit(n_type)
		v.enter_visit(n_annotations)
		v.enter_visit(n_expr)
	end
end
redef class AMethPropdef
	private init empty_init do end

	init init_amethpropdef (
		ndoc: nullable ADoc,
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nmethid: nullable AMethid,
		nsignature: nullable ASignature
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_methid = nmethid
		if nmethid != null then nmethid.parent = self
		n_signature = nsignature.as(not null)
		nsignature.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_methid == old_child then
			n_methid = new_child.as(nullable AMethid)
			return
		end
		if n_signature == old_child then
			n_signature = new_child.as(ASignature)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_methid=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_signature=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_methid)
		v.enter_visit(n_signature)
	end
end
redef class ADeferredMethPropdef
	private init empty_init do end

	init init_adeferredmethpropdef (
		ndoc: nullable ADoc,
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nkwmeth: nullable TKwmeth,
		nmethid: nullable AMethid,
		nsignature: nullable ASignature,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_kwmeth = nkwmeth.as(not null)
		nkwmeth.parent = self
		n_methid = nmethid.as(not null)
		nmethid.parent = self
		n_signature = nsignature.as(not null)
		nsignature.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_kwmeth == old_child then
			n_kwmeth = new_child.as(TKwmeth)
			return
		end
		if n_methid == old_child then
			n_methid = new_child.as(AMethid)
			return
		end
		if n_signature == old_child then
			n_signature = new_child.as(ASignature)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwmeth=(node)
	do
		super
		node.parent = self
	end
	redef fun n_methid=(node)
	do
		super
		node.parent = self
	end
	redef fun n_signature=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwmeth)
		v.enter_visit(n_methid)
		v.enter_visit(n_signature)
		v.enter_visit(n_annotations)
	end
end
redef class AInternMethPropdef
	private init empty_init do end

	init init_ainternmethpropdef (
		ndoc: nullable ADoc,
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nkwmeth: nullable TKwmeth,
		nmethid: nullable AMethid,
		nsignature: nullable ASignature
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_kwmeth = nkwmeth.as(not null)
		nkwmeth.parent = self
		n_methid = nmethid.as(not null)
		nmethid.parent = self
		n_signature = nsignature.as(not null)
		nsignature.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_kwmeth == old_child then
			n_kwmeth = new_child.as(TKwmeth)
			return
		end
		if n_methid == old_child then
			n_methid = new_child.as(AMethid)
			return
		end
		if n_signature == old_child then
			n_signature = new_child.as(ASignature)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwmeth=(node)
	do
		super
		node.parent = self
	end
	redef fun n_methid=(node)
	do
		super
		node.parent = self
	end
	redef fun n_signature=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwmeth)
		v.enter_visit(n_methid)
		v.enter_visit(n_signature)
	end
end
redef class AExternMethPropdef
	private init empty_init do end

	init init_aexternmethpropdef (
		ndoc: nullable ADoc,
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nkwmeth: nullable TKwmeth,
		nmethid: nullable AMethid,
		nsignature: nullable ASignature,
		nextern: nullable TString,
		nextern_calls: nullable AExternCalls,
		nextern_code_block: nullable AExternCodeBlock
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_kwmeth = nkwmeth.as(not null)
		nkwmeth.parent = self
		n_methid = nmethid.as(not null)
		nmethid.parent = self
		n_signature = nsignature.as(not null)
		nsignature.parent = self
		n_extern = nextern
		if nextern != null then nextern.parent = self
		n_extern_calls = nextern_calls
		if nextern_calls != null then nextern_calls.parent = self
		n_extern_code_block = nextern_code_block
		if nextern_code_block != null then nextern_code_block.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_kwmeth == old_child then
			n_kwmeth = new_child.as(TKwmeth)
			return
		end
		if n_methid == old_child then
			n_methid = new_child.as(AMethid)
			return
		end
		if n_signature == old_child then
			n_signature = new_child.as(ASignature)
			return
		end
		if n_extern == old_child then
			n_extern = new_child.as(nullable TString)
			return
		end
		if n_extern_calls == old_child then
			n_extern_calls = new_child.as(nullable AExternCalls)
			return
		end
		if n_extern_code_block == old_child then
			n_extern_code_block = new_child.as(nullable AExternCodeBlock)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwmeth=(node)
	do
		super
		node.parent = self
	end
	redef fun n_methid=(node)
	do
		super
		node.parent = self
	end
	redef fun n_signature=(node)
	do
		super
		node.parent = self
	end
	redef fun n_extern=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_extern_calls=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_extern_code_block=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwmeth)
		v.enter_visit(n_methid)
		v.enter_visit(n_signature)
		v.enter_visit(n_extern)
		v.enter_visit(n_extern_calls)
		v.enter_visit(n_extern_code_block)
	end
end
redef class AConcreteMethPropdef
	private init empty_init do end

	init init_aconcretemethpropdef (
		ndoc: nullable ADoc,
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nkwmeth: nullable TKwmeth,
		nmethid: nullable AMethid,
		nsignature: nullable ASignature,
		nannotations: nullable AAnnotations,
		nblock: nullable AExpr
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_kwmeth = nkwmeth.as(not null)
		nkwmeth.parent = self
		n_methid = nmethid
		if nmethid != null then nmethid.parent = self
		n_signature = nsignature.as(not null)
		nsignature.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
		n_block = nblock
		if nblock != null then nblock.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_kwmeth == old_child then
			n_kwmeth = new_child.as(TKwmeth)
			return
		end
		if n_methid == old_child then
			n_methid = new_child.as(nullable AMethid)
			return
		end
		if n_signature == old_child then
			n_signature = new_child.as(ASignature)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
		if n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwmeth=(node)
	do
		super
		node.parent = self
	end
	redef fun n_methid=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_signature=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_block=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwmeth)
		v.enter_visit(n_methid)
		v.enter_visit(n_signature)
		v.enter_visit(n_annotations)
		v.enter_visit(n_block)
	end
end
redef class AConcreteInitPropdef
	private init empty_init do end

	init init_aconcreteinitpropdef (
		ndoc: nullable ADoc,
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nkwinit: nullable TKwinit,
		nmethid: nullable AMethid,
		nsignature: nullable ASignature,
		nannotations: nullable AAnnotations,
		nblock: nullable AExpr
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_kwinit = nkwinit.as(not null)
		nkwinit.parent = self
		n_methid = nmethid
		if nmethid != null then nmethid.parent = self
		n_signature = nsignature.as(not null)
		nsignature.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
		n_block = nblock
		if nblock != null then nblock.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_kwinit == old_child then
			n_kwinit = new_child.as(TKwinit)
			return
		end
		if n_methid == old_child then
			n_methid = new_child.as(nullable AMethid)
			return
		end
		if n_signature == old_child then
			n_signature = new_child.as(ASignature)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
		if n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwinit=(node)
	do
		super
		node.parent = self
	end
	redef fun n_methid=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_signature=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_block=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwinit)
		v.enter_visit(n_methid)
		v.enter_visit(n_signature)
		v.enter_visit(n_annotations)
		v.enter_visit(n_block)
	end
end
redef class AExternInitPropdef
	private init empty_init do end

	init init_aexterninitpropdef (
		ndoc: nullable ADoc,
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nkwnew: nullable TKwnew,
		nmethid: nullable AMethid,
		nsignature: nullable ASignature,
		nextern: nullable TString,
		nextern_calls: nullable AExternCalls,
		nextern_code_block: nullable AExternCodeBlock
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_kwnew = nkwnew.as(not null)
		nkwnew.parent = self
		n_methid = nmethid
		if nmethid != null then nmethid.parent = self
		n_signature = nsignature.as(not null)
		nsignature.parent = self
		n_extern = nextern
		if nextern != null then nextern.parent = self
		n_extern_calls = nextern_calls
		if nextern_calls != null then nextern_calls.parent = self
		n_extern_code_block = nextern_code_block
		if nextern_code_block != null then nextern_code_block.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_kwnew == old_child then
			n_kwnew = new_child.as(TKwnew)
			return
		end
		if n_methid == old_child then
			n_methid = new_child.as(nullable AMethid)
			return
		end
		if n_signature == old_child then
			n_signature = new_child.as(ASignature)
			return
		end
		if n_extern == old_child then
			n_extern = new_child.as(nullable TString)
			return
		end
		if n_extern_calls == old_child then
			n_extern_calls = new_child.as(nullable AExternCalls)
			return
		end
		if n_extern_code_block == old_child then
			n_extern_code_block = new_child.as(nullable AExternCodeBlock)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwnew=(node)
	do
		super
		node.parent = self
	end
	redef fun n_methid=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_signature=(node)
	do
		super
		node.parent = self
	end
	redef fun n_extern=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_extern_calls=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_extern_code_block=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwnew)
		v.enter_visit(n_methid)
		v.enter_visit(n_signature)
		v.enter_visit(n_extern)
		v.enter_visit(n_extern_calls)
		v.enter_visit(n_extern_code_block)
	end
end
redef class AMainMethPropdef
	private init empty_init do end

	init init_amainmethpropdef (
		nkwredef: nullable TKwredef,
		nblock: nullable AExpr
	)
	do
		empty_init
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_block = nblock
		if nblock != null then nblock.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_block=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwredef)
		v.enter_visit(n_block)
	end
end
redef class ATypePropdef
	private init empty_init do end

	init init_atypepropdef (
		ndoc: nullable ADoc,
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nkwtype: nullable TKwtype,
		nid: nullable TClassid,
		ntype: nullable AType,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_doc = ndoc
		if ndoc != null then ndoc.parent = self
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility.as(not null)
		nvisibility.parent = self
		n_kwtype = nkwtype.as(not null)
		nkwtype.parent = self
		n_id = nid.as(not null)
		nid.parent = self
		n_type = ntype.as(not null)
		ntype.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_doc == old_child then
			n_doc = new_child.as(nullable ADoc)
			return
		end
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(AVisibility)
			return
		end
		if n_kwtype == old_child then
			n_kwtype = new_child.as(TKwtype)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TClassid)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_doc=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwtype=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_doc)
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwtype)
		v.enter_visit(n_id)
		v.enter_visit(n_type)
		v.enter_visit(n_annotations)
	end
end
redef class AReadAble
	private init empty_init do end

	init init_areadable (
		nkwredef: nullable TKwredef,
		nkwreadable: nullable TKwreadable
	)
	do
		empty_init
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_kwreadable = nkwreadable.as(not null)
		nkwreadable.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_kwreadable == old_child then
			n_kwreadable = new_child.as(TKwreadable)
			return
		end
	end

	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwreadable=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwredef)
		v.enter_visit(n_kwreadable)
	end
end
redef class AWriteAble
	private init empty_init do end

	init init_awriteable (
		nkwredef: nullable TKwredef,
		nvisibility: nullable AVisibility,
		nkwwritable: nullable TKwwritable
	)
	do
		empty_init
		n_kwredef = nkwredef
		if nkwredef != null then nkwredef.parent = self
		n_visibility = nvisibility
		if nvisibility != null then nvisibility.parent = self
		n_kwwritable = nkwwritable.as(not null)
		nkwwritable.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwredef == old_child then
			n_kwredef = new_child.as(nullable TKwredef)
			return
		end
		if n_visibility == old_child then
			n_visibility = new_child.as(nullable AVisibility)
			return
		end
		if n_kwwritable == old_child then
			n_kwwritable = new_child.as(TKwwritable)
			return
		end
	end

	redef fun n_kwredef=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_visibility=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwwritable=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwredef)
		v.enter_visit(n_visibility)
		v.enter_visit(n_kwwritable)
	end
end
redef class AIdMethid
	private init empty_init do end

	init init_aidmethid (
		nid: nullable TId
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
	end
end
redef class APlusMethid
	private init empty_init do end

	init init_aplusmethid (
		nplus: nullable TPlus
	)
	do
		empty_init
		n_plus = nplus.as(not null)
		nplus.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_plus == old_child then
			n_plus = new_child.as(TPlus)
			return
		end
	end

	redef fun n_plus=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_plus)
	end
end
redef class AMinusMethid
	private init empty_init do end

	init init_aminusmethid (
		nminus: nullable TMinus
	)
	do
		empty_init
		n_minus = nminus.as(not null)
		nminus.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_minus == old_child then
			n_minus = new_child.as(TMinus)
			return
		end
	end

	redef fun n_minus=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_minus)
	end
end
redef class AStarMethid
	private init empty_init do end

	init init_astarmethid (
		nstar: nullable TStar
	)
	do
		empty_init
		n_star = nstar.as(not null)
		nstar.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_star == old_child then
			n_star = new_child.as(TStar)
			return
		end
	end

	redef fun n_star=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_star)
	end
end
redef class ASlashMethid
	private init empty_init do end

	init init_aslashmethid (
		nslash: nullable TSlash
	)
	do
		empty_init
		n_slash = nslash.as(not null)
		nslash.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_slash == old_child then
			n_slash = new_child.as(TSlash)
			return
		end
	end

	redef fun n_slash=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_slash)
	end
end
redef class APercentMethid
	private init empty_init do end

	init init_apercentmethid (
		npercent: nullable TPercent
	)
	do
		empty_init
		n_percent = npercent.as(not null)
		npercent.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_percent == old_child then
			n_percent = new_child.as(TPercent)
			return
		end
	end

	redef fun n_percent=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_percent)
	end
end
redef class AEqMethid
	private init empty_init do end

	init init_aeqmethid (
		neq: nullable TEq
	)
	do
		empty_init
		n_eq = neq.as(not null)
		neq.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_eq == old_child then
			n_eq = new_child.as(TEq)
			return
		end
	end

	redef fun n_eq=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_eq)
	end
end
redef class ANeMethid
	private init empty_init do end

	init init_anemethid (
		nne: nullable TNe
	)
	do
		empty_init
		n_ne = nne.as(not null)
		nne.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_ne == old_child then
			n_ne = new_child.as(TNe)
			return
		end
	end

	redef fun n_ne=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_ne)
	end
end
redef class ALeMethid
	private init empty_init do end

	init init_alemethid (
		nle: nullable TLe
	)
	do
		empty_init
		n_le = nle.as(not null)
		nle.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_le == old_child then
			n_le = new_child.as(TLe)
			return
		end
	end

	redef fun n_le=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_le)
	end
end
redef class AGeMethid
	private init empty_init do end

	init init_agemethid (
		nge: nullable TGe
	)
	do
		empty_init
		n_ge = nge.as(not null)
		nge.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_ge == old_child then
			n_ge = new_child.as(TGe)
			return
		end
	end

	redef fun n_ge=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_ge)
	end
end
redef class ALtMethid
	private init empty_init do end

	init init_altmethid (
		nlt: nullable TLt
	)
	do
		empty_init
		n_lt = nlt.as(not null)
		nlt.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_lt == old_child then
			n_lt = new_child.as(TLt)
			return
		end
	end

	redef fun n_lt=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_lt)
	end
end
redef class AGtMethid
	private init empty_init do end

	init init_agtmethid (
		ngt: nullable TGt
	)
	do
		empty_init
		n_gt = ngt.as(not null)
		ngt.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_gt == old_child then
			n_gt = new_child.as(TGt)
			return
		end
	end

	redef fun n_gt=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_gt)
	end
end
redef class ALlMethid
	private init empty_init do end

	init init_allmethid (
		nll: nullable TLl
	)
	do
		empty_init
		n_ll = nll.as(not null)
		nll.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_ll == old_child then
			n_ll = new_child.as(TLl)
			return
		end
	end

	redef fun n_ll=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_ll)
	end
end
redef class AGgMethid
	private init empty_init do end

	init init_aggmethid (
		ngg: nullable TGg
	)
	do
		empty_init
		n_gg = ngg.as(not null)
		ngg.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_gg == old_child then
			n_gg = new_child.as(TGg)
			return
		end
	end

	redef fun n_gg=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_gg)
	end
end
redef class ABraMethid
	private init empty_init do end

	init init_abramethid (
		nobra: nullable TObra,
		ncbra: nullable TCbra
	)
	do
		empty_init
		n_obra = nobra.as(not null)
		nobra.parent = self
		n_cbra = ncbra.as(not null)
		ncbra.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if n_cbra == old_child then
			n_cbra = new_child.as(TCbra)
			return
		end
	end

	redef fun n_obra=(node)
	do
		super
		node.parent = self
	end
	redef fun n_cbra=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_obra)
		v.enter_visit(n_cbra)
	end
end
redef class AStarshipMethid
	private init empty_init do end

	init init_astarshipmethid (
		nstarship: nullable TStarship
	)
	do
		empty_init
		n_starship = nstarship.as(not null)
		nstarship.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_starship == old_child then
			n_starship = new_child.as(TStarship)
			return
		end
	end

	redef fun n_starship=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_starship)
	end
end
redef class AAssignMethid
	private init empty_init do end

	init init_aassignmethid (
		nid: nullable TId,
		nassign: nullable TAssign
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
		n_assign = nassign.as(not null)
		nassign.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
		v.enter_visit(n_assign)
	end
end
redef class ABraassignMethid
	private init empty_init do end

	init init_abraassignmethid (
		nobra: nullable TObra,
		ncbra: nullable TCbra,
		nassign: nullable TAssign
	)
	do
		empty_init
		n_obra = nobra.as(not null)
		nobra.parent = self
		n_cbra = ncbra.as(not null)
		ncbra.parent = self
		n_assign = nassign.as(not null)
		nassign.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if n_cbra == old_child then
			n_cbra = new_child.as(TCbra)
			return
		end
		if n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
	end

	redef fun n_obra=(node)
	do
		super
		node.parent = self
	end
	redef fun n_cbra=(node)
	do
		super
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_obra)
		v.enter_visit(n_cbra)
		v.enter_visit(n_assign)
	end
end
redef class ASignature
	private init empty_init do end

	init init_asignature (
		nopar: nullable TOpar,
		nparams: Collection[Object], # Should be Collection[AParam]
		ncpar: nullable TCpar,
		ntype: nullable AType
	)
	do
		empty_init
		n_opar = nopar
		if nopar != null then nopar.parent = self
		n_params.unsafe_add_all(nparams)
		n_cpar = ncpar
		if ncpar != null then ncpar.parent = self
		n_type = ntype
		if ntype != null then ntype.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if n_params.replace_child(old_child, new_child) then return
		if n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
	end

	redef fun n_opar=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_cpar=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_opar)
		n_params.visit_all(v)
		v.enter_visit(n_cpar)
		v.enter_visit(n_type)
	end
end
redef class AParam
	private init empty_init do end

	init init_aparam (
		nid: nullable TId,
		ntype: nullable AType,
		ndotdotdot: nullable TDotdotdot,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
		n_type = ntype
		if ntype != null then ntype.parent = self
		n_dotdotdot = ndotdotdot
		if ndotdotdot != null then ndotdotdot.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
		if n_dotdotdot == old_child then
			n_dotdotdot = new_child.as(nullable TDotdotdot)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_dotdotdot=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
		v.enter_visit(n_type)
		v.enter_visit(n_dotdotdot)
		v.enter_visit(n_annotations)
	end
end
redef class AType
	private init empty_init do end

	init init_atype (
		nkwnullable: nullable TKwnullable,
		nid: nullable TClassid,
		ntypes: Collection[Object], # Should be Collection[AType]
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_kwnullable = nkwnullable
		if nkwnullable != null then nkwnullable.parent = self
		n_id = nid.as(not null)
		nid.parent = self
		n_types.unsafe_add_all(ntypes)
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwnullable == old_child then
			n_kwnullable = new_child.as(nullable TKwnullable)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TClassid)
			return
		end
		if n_types.replace_child(old_child, new_child) then return
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwnullable=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwnullable)
		v.enter_visit(n_id)
		n_types.visit_all(v)
		v.enter_visit(n_annotations)
	end
end
redef class ALabel
	private init empty_init do end

	init init_alabel (
		nkwlabel: nullable TKwlabel,
		nid: nullable TId
	)
	do
		empty_init
		n_kwlabel = nkwlabel.as(not null)
		nkwlabel.parent = self
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwlabel == old_child then
			n_kwlabel = new_child.as(TKwlabel)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
	end

	redef fun n_kwlabel=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwlabel)
		v.enter_visit(n_id)
	end
end
redef class ABlockExpr
	private init empty_init do end

	init init_ablockexpr (
		nexpr: Collection[Object], # Should be Collection[AExpr]
		nkwend: nullable TKwend
	)
	do
		empty_init
		n_expr.unsafe_add_all(nexpr)
		n_kwend = nkwend
		if nkwend != null then nkwend.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr.replace_child(old_child, new_child) then return
		if n_kwend == old_child then
			n_kwend = new_child.as(nullable TKwend)
			return
		end
	end

	redef fun n_kwend=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		n_expr.visit_all(v)
		v.enter_visit(n_kwend)
	end
end
redef class AVardeclExpr
	private init empty_init do end

	init init_avardeclexpr (
		nkwvar: nullable TKwvar,
		nid: nullable TId,
		ntype: nullable AType,
		nassign: nullable TAssign,
		nexpr: nullable AExpr,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_kwvar = nkwvar.as(not null)
		nkwvar.parent = self
		n_id = nid.as(not null)
		nid.parent = self
		n_type = ntype
		if ntype != null then ntype.parent = self
		n_assign = nassign
		if nassign != null then nassign.parent = self
		n_expr = nexpr
		if nexpr != null then nexpr.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwvar == old_child then
			n_kwvar = new_child.as(TKwvar)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(nullable AType)
			return
		end
		if n_assign == old_child then
			n_assign = new_child.as(nullable TAssign)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(nullable AExpr)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwvar=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_assign=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwvar)
		v.enter_visit(n_id)
		v.enter_visit(n_type)
		v.enter_visit(n_assign)
		v.enter_visit(n_expr)
		v.enter_visit(n_annotations)
	end
end
redef class AReturnExpr
	private init empty_init do end

	init init_areturnexpr (
		nkwreturn: nullable TKwreturn,
		nexpr: nullable AExpr
	)
	do
		empty_init
		n_kwreturn = nkwreturn
		if nkwreturn != null then nkwreturn.parent = self
		n_expr = nexpr
		if nexpr != null then nexpr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwreturn == old_child then
			n_kwreturn = new_child.as(nullable TKwreturn)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_kwreturn=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwreturn)
		v.enter_visit(n_expr)
	end
end
redef class ABreakExpr
	private init empty_init do end

	init init_abreakexpr (
		nkwbreak: nullable TKwbreak,
		nlabel: nullable ALabel,
		nexpr: nullable AExpr
	)
	do
		empty_init
		n_kwbreak = nkwbreak.as(not null)
		nkwbreak.parent = self
		n_label = nlabel
		if nlabel != null then nlabel.parent = self
		n_expr = nexpr
		if nexpr != null then nexpr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwbreak == old_child then
			n_kwbreak = new_child.as(TKwbreak)
			return
		end
		if n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_kwbreak=(node)
	do
		super
		node.parent = self
	end
	redef fun n_label=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwbreak)
		v.enter_visit(n_label)
		v.enter_visit(n_expr)
	end
end
redef class AAbortExpr
	private init empty_init do end

	init init_aabortexpr (
		nkwabort: nullable TKwabort
	)
	do
		empty_init
		n_kwabort = nkwabort.as(not null)
		nkwabort.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwabort == old_child then
			n_kwabort = new_child.as(TKwabort)
			return
		end
	end

	redef fun n_kwabort=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwabort)
	end
end
redef class AContinueExpr
	private init empty_init do end

	init init_acontinueexpr (
		nkwcontinue: nullable TKwcontinue,
		nlabel: nullable ALabel,
		nexpr: nullable AExpr
	)
	do
		empty_init
		n_kwcontinue = nkwcontinue
		if nkwcontinue != null then nkwcontinue.parent = self
		n_label = nlabel
		if nlabel != null then nlabel.parent = self
		n_expr = nexpr
		if nexpr != null then nexpr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwcontinue == old_child then
			n_kwcontinue = new_child.as(nullable TKwcontinue)
			return
		end
		if n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_kwcontinue=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwcontinue)
		v.enter_visit(n_label)
		v.enter_visit(n_expr)
	end
end
redef class ADoExpr
	private init empty_init do end

	init init_adoexpr (
		nkwdo: nullable TKwdo,
		nblock: nullable AExpr,
		nlabel: nullable ALabel
	)
	do
		empty_init
		n_kwdo = nkwdo.as(not null)
		nkwdo.parent = self
		n_block = nblock
		if nblock != null then nblock.parent = self
		n_label = nlabel
		if nlabel != null then nlabel.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwdo == old_child then
			n_kwdo = new_child.as(TKwdo)
			return
		end
		if n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
		if n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwdo=(node)
	do
		super
		node.parent = self
	end
	redef fun n_block=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwdo)
		v.enter_visit(n_block)
		v.enter_visit(n_label)
	end
end
redef class AIfExpr
	private init empty_init do end

	init init_aifexpr (
		nkwif: nullable TKwif,
		nexpr: nullable AExpr,
		nthen: nullable AExpr,
		nelse: nullable AExpr
	)
	do
		empty_init
		n_kwif = nkwif.as(not null)
		nkwif.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_then = nthen
		if nthen != null then nthen.parent = self
		n_else = nelse
		if nelse != null then nelse.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwif == old_child then
			n_kwif = new_child.as(TKwif)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_then == old_child then
			n_then = new_child.as(nullable AExpr)
			return
		end
		if n_else == old_child then
			n_else = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_kwif=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_then=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_else=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwif)
		v.enter_visit(n_expr)
		v.enter_visit(n_then)
		v.enter_visit(n_else)
	end
end
redef class AIfexprExpr
	private init empty_init do end

	init init_aifexprexpr (
		nkwif: nullable TKwif,
		nexpr: nullable AExpr,
		nkwthen: nullable TKwthen,
		nthen: nullable AExpr,
		nkwelse: nullable TKwelse,
		nelse: nullable AExpr
	)
	do
		empty_init
		n_kwif = nkwif.as(not null)
		nkwif.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_kwthen = nkwthen.as(not null)
		nkwthen.parent = self
		n_then = nthen.as(not null)
		nthen.parent = self
		n_kwelse = nkwelse.as(not null)
		nkwelse.parent = self
		n_else = nelse.as(not null)
		nelse.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwif == old_child then
			n_kwif = new_child.as(TKwif)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_kwthen == old_child then
			n_kwthen = new_child.as(TKwthen)
			return
		end
		if n_then == old_child then
			n_then = new_child.as(AExpr)
			return
		end
		if n_kwelse == old_child then
			n_kwelse = new_child.as(TKwelse)
			return
		end
		if n_else == old_child then
			n_else = new_child.as(AExpr)
			return
		end
	end

	redef fun n_kwif=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwthen=(node)
	do
		super
		node.parent = self
	end
	redef fun n_then=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwelse=(node)
	do
		super
		node.parent = self
	end
	redef fun n_else=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwif)
		v.enter_visit(n_expr)
		v.enter_visit(n_kwthen)
		v.enter_visit(n_then)
		v.enter_visit(n_kwelse)
		v.enter_visit(n_else)
	end
end
redef class AWhileExpr
	private init empty_init do end

	init init_awhileexpr (
		nkwwhile: nullable TKwwhile,
		nexpr: nullable AExpr,
		nkwdo: nullable TKwdo,
		nblock: nullable AExpr,
		nlabel: nullable ALabel
	)
	do
		empty_init
		n_kwwhile = nkwwhile.as(not null)
		nkwwhile.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_kwdo = nkwdo.as(not null)
		nkwdo.parent = self
		n_block = nblock
		if nblock != null then nblock.parent = self
		n_label = nlabel
		if nlabel != null then nlabel.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwwhile == old_child then
			n_kwwhile = new_child.as(TKwwhile)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_kwdo == old_child then
			n_kwdo = new_child.as(TKwdo)
			return
		end
		if n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
		if n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwwhile=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwdo=(node)
	do
		super
		node.parent = self
	end
	redef fun n_block=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwwhile)
		v.enter_visit(n_expr)
		v.enter_visit(n_kwdo)
		v.enter_visit(n_block)
		v.enter_visit(n_label)
	end
end
redef class ALoopExpr
	private init empty_init do end

	init init_aloopexpr (
		nkwloop: nullable TKwloop,
		nblock: nullable AExpr,
		nlabel: nullable ALabel
	)
	do
		empty_init
		n_kwloop = nkwloop.as(not null)
		nkwloop.parent = self
		n_block = nblock
		if nblock != null then nblock.parent = self
		n_label = nlabel
		if nlabel != null then nlabel.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwloop == old_child then
			n_kwloop = new_child.as(TKwloop)
			return
		end
		if n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
		if n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwloop=(node)
	do
		super
		node.parent = self
	end
	redef fun n_block=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwloop)
		v.enter_visit(n_block)
		v.enter_visit(n_label)
	end
end
redef class AForExpr
	private init empty_init do end

	init init_aforexpr (
		nkwfor: nullable TKwfor,
		nids: Collection[Object], # Should be Collection[TId]
		nexpr: nullable AExpr,
		nkwdo: nullable TKwdo,
		nblock: nullable AExpr,
		nlabel: nullable ALabel
	)
	do
		empty_init
		n_kwfor = nkwfor.as(not null)
		nkwfor.parent = self
		n_ids.unsafe_add_all(nids)
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_kwdo = nkwdo.as(not null)
		nkwdo.parent = self
		n_block = nblock
		if nblock != null then nblock.parent = self
		n_label = nlabel
		if nlabel != null then nlabel.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwfor == old_child then
			n_kwfor = new_child.as(TKwfor)
			return
		end
		if n_ids.replace_child(old_child, new_child) then return
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_kwdo == old_child then
			n_kwdo = new_child.as(TKwdo)
			return
		end
		if n_block == old_child then
			n_block = new_child.as(nullable AExpr)
			return
		end
		if n_label == old_child then
			n_label = new_child.as(nullable ALabel)
			return
		end
	end

	redef fun n_kwfor=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwdo=(node)
	do
		super
		node.parent = self
	end
	redef fun n_block=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_label=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwfor)
		n_ids.visit_all(v)
		v.enter_visit(n_expr)
		v.enter_visit(n_kwdo)
		v.enter_visit(n_block)
		v.enter_visit(n_label)
	end
end
redef class AAssertExpr
	private init empty_init do end

	init init_aassertexpr (
		nkwassert: nullable TKwassert,
		nid: nullable TId,
		nexpr: nullable AExpr,
		nelse: nullable AExpr
	)
	do
		empty_init
		n_kwassert = nkwassert.as(not null)
		nkwassert.parent = self
		n_id = nid
		if nid != null then nid.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_else = nelse
		if nelse != null then nelse.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwassert == old_child then
			n_kwassert = new_child.as(TKwassert)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(nullable TId)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_else == old_child then
			n_else = new_child.as(nullable AExpr)
			return
		end
	end

	redef fun n_kwassert=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_else=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwassert)
		v.enter_visit(n_id)
		v.enter_visit(n_expr)
		v.enter_visit(n_else)
	end
end
redef class AOnceExpr
	private init empty_init do end

	init init_aonceexpr (
		nkwonce: nullable TKwonce,
		nexpr: nullable AExpr
	)
	do
		empty_init
		n_kwonce = nkwonce.as(not null)
		nkwonce.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwonce == old_child then
			n_kwonce = new_child.as(TKwonce)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
	end

	redef fun n_kwonce=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwonce)
		v.enter_visit(n_expr)
	end
end
redef class ASendExpr
	private init empty_init do end

	init init_asendexpr (
		nexpr: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
	end
end
redef class ABinopExpr
	private init empty_init do end

	init init_abinopexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AOrExpr
	private init empty_init do end

	init init_aorexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AAndExpr
	private init empty_init do end

	init init_aandexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AOrElseExpr
	private init empty_init do end

	init init_aorelseexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AImpliesExpr
	private init empty_init do end

	init init_aimpliesexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class ANotExpr
	private init empty_init do end

	init init_anotexpr (
		nkwnot: nullable TKwnot,
		nexpr: nullable AExpr
	)
	do
		empty_init
		n_kwnot = nkwnot.as(not null)
		nkwnot.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwnot == old_child then
			n_kwnot = new_child.as(TKwnot)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
	end

	redef fun n_kwnot=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwnot)
		v.enter_visit(n_expr)
	end
end
redef class AEqExpr
	private init empty_init do end

	init init_aeqexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class ANeExpr
	private init empty_init do end

	init init_aneexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class ALtExpr
	private init empty_init do end

	init init_altexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class ALeExpr
	private init empty_init do end

	init init_aleexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class ALlExpr
	private init empty_init do end

	init init_allexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AGtExpr
	private init empty_init do end

	init init_agtexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AGeExpr
	private init empty_init do end

	init init_ageexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AGgExpr
	private init empty_init do end

	init init_aggexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AIsaExpr
	private init empty_init do end

	init init_aisaexpr (
		nexpr: nullable AExpr,
		ntype: nullable AType
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_type = ntype.as(not null)
		ntype.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_type)
	end
end
redef class APlusExpr
	private init empty_init do end

	init init_aplusexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AMinusExpr
	private init empty_init do end

	init init_aminusexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AStarshipExpr
	private init empty_init do end

	init init_astarshipexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AStarExpr
	private init empty_init do end

	init init_astarexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class ASlashExpr
	private init empty_init do end

	init init_aslashexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class APercentExpr
	private init empty_init do end

	init init_apercentexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
	end
end
redef class AUminusExpr
	private init empty_init do end

	init init_auminusexpr (
		nminus: nullable TMinus,
		nexpr: nullable AExpr
	)
	do
		empty_init
		n_minus = nminus.as(not null)
		nminus.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_minus == old_child then
			n_minus = new_child.as(TMinus)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
	end

	redef fun n_minus=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_minus)
		v.enter_visit(n_expr)
	end
end
redef class ANewExpr
	private init empty_init do end

	init init_anewexpr (
		nkwnew: nullable TKwnew,
		ntype: nullable AType,
		nid: nullable TId,
		nargs: nullable AExprs
	)
	do
		empty_init
		n_kwnew = nkwnew.as(not null)
		nkwnew.parent = self
		n_type = ntype.as(not null)
		ntype.parent = self
		n_id = nid
		if nid != null then nid.parent = self
		n_args = nargs.as(not null)
		nargs.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwnew == old_child then
			n_kwnew = new_child.as(TKwnew)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(nullable TId)
			return
		end
		if n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
	end

	redef fun n_kwnew=(node)
	do
		super
		node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_args=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwnew)
		v.enter_visit(n_type)
		v.enter_visit(n_id)
		v.enter_visit(n_args)
	end
end
redef class AAttrExpr
	private init empty_init do end

	init init_aattrexpr (
		nexpr: nullable AExpr,
		nid: nullable TAttrid
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TAttrid)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_id)
	end
end
redef class AAttrAssignExpr
	private init empty_init do end

	init init_aattrassignexpr (
		nexpr: nullable AExpr,
		nid: nullable TAttrid,
		nassign: nullable TAssign,
		nvalue: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_id = nid.as(not null)
		nid.parent = self
		n_assign = nassign.as(not null)
		nassign.parent = self
		n_value = nvalue.as(not null)
		nvalue.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TAttrid)
			return
		end
		if n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
		if n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		super
		node.parent = self
	end
	redef fun n_value=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_id)
		v.enter_visit(n_assign)
		v.enter_visit(n_value)
	end
end
redef class AAttrReassignExpr
	private init empty_init do end

	init init_aattrreassignexpr (
		nexpr: nullable AExpr,
		nid: nullable TAttrid,
		nassign_op: nullable AAssignOp,
		nvalue: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_id = nid.as(not null)
		nid.parent = self
		n_assign_op = nassign_op.as(not null)
		nassign_op.parent = self
		n_value = nvalue.as(not null)
		nvalue.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TAttrid)
			return
		end
		if n_assign_op == old_child then
			n_assign_op = new_child.as(AAssignOp)
			return
		end
		if n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_assign_op=(node)
	do
		super
		node.parent = self
	end
	redef fun n_value=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_id)
		v.enter_visit(n_assign_op)
		v.enter_visit(n_value)
	end
end
redef class ACallExpr
	private init empty_init do end

	init init_acallexpr (
		nexpr: nullable AExpr,
		nid: nullable TId,
		nargs: nullable AExprs
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_id = nid.as(not null)
		nid.parent = self
		n_args = nargs.as(not null)
		nargs.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_args=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_id)
		v.enter_visit(n_args)
	end
end
redef class ACallAssignExpr
	private init empty_init do end

	init init_acallassignexpr (
		nexpr: nullable AExpr,
		nid: nullable TId,
		nargs: nullable AExprs,
		nassign: nullable TAssign,
		nvalue: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_id = nid.as(not null)
		nid.parent = self
		n_args = nargs.as(not null)
		nargs.parent = self
		n_assign = nassign.as(not null)
		nassign.parent = self
		n_value = nvalue.as(not null)
		nvalue.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
		if n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
		if n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_args=(node)
	do
		super
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		super
		node.parent = self
	end
	redef fun n_value=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_id)
		v.enter_visit(n_args)
		v.enter_visit(n_assign)
		v.enter_visit(n_value)
	end
end
redef class ACallReassignExpr
	private init empty_init do end

	init init_acallreassignexpr (
		nexpr: nullable AExpr,
		nid: nullable TId,
		nargs: nullable AExprs,
		nassign_op: nullable AAssignOp,
		nvalue: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_id = nid.as(not null)
		nid.parent = self
		n_args = nargs.as(not null)
		nargs.parent = self
		n_assign_op = nassign_op.as(not null)
		nassign_op.parent = self
		n_value = nvalue.as(not null)
		nvalue.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
		if n_assign_op == old_child then
			n_assign_op = new_child.as(AAssignOp)
			return
		end
		if n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_args=(node)
	do
		super
		node.parent = self
	end
	redef fun n_assign_op=(node)
	do
		super
		node.parent = self
	end
	redef fun n_value=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_id)
		v.enter_visit(n_args)
		v.enter_visit(n_assign_op)
		v.enter_visit(n_value)
	end
end
redef class ASuperExpr
	private init empty_init do end

	init init_asuperexpr (
		nqualified: nullable AQualified,
		nkwsuper: nullable TKwsuper,
		nargs: nullable AExprs
	)
	do
		empty_init
		n_qualified = nqualified
		if nqualified != null then nqualified.parent = self
		n_kwsuper = nkwsuper.as(not null)
		nkwsuper.parent = self
		n_args = nargs.as(not null)
		nargs.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_qualified == old_child then
			n_qualified = new_child.as(nullable AQualified)
			return
		end
		if n_kwsuper == old_child then
			n_kwsuper = new_child.as(TKwsuper)
			return
		end
		if n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
	end

	redef fun n_qualified=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwsuper=(node)
	do
		super
		node.parent = self
	end
	redef fun n_args=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_qualified)
		v.enter_visit(n_kwsuper)
		v.enter_visit(n_args)
	end
end
redef class AInitExpr
	private init empty_init do end

	init init_ainitexpr (
		nexpr: nullable AExpr,
		nkwinit: nullable TKwinit,
		nargs: nullable AExprs
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_kwinit = nkwinit.as(not null)
		nkwinit.parent = self
		n_args = nargs.as(not null)
		nargs.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_kwinit == old_child then
			n_kwinit = new_child.as(TKwinit)
			return
		end
		if n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwinit=(node)
	do
		super
		node.parent = self
	end
	redef fun n_args=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_kwinit)
		v.enter_visit(n_args)
	end
end
redef class ABraExpr
	private init empty_init do end

	init init_abraexpr (
		nexpr: nullable AExpr,
		nargs: nullable AExprs
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_args = nargs.as(not null)
		nargs.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_args=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_args)
	end
end
redef class ABraAssignExpr
	private init empty_init do end

	init init_abraassignexpr (
		nexpr: nullable AExpr,
		nargs: nullable AExprs,
		nassign: nullable TAssign,
		nvalue: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_args = nargs.as(not null)
		nargs.parent = self
		n_assign = nassign.as(not null)
		nassign.parent = self
		n_value = nvalue.as(not null)
		nvalue.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
		if n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
		if n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_args=(node)
	do
		super
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		super
		node.parent = self
	end
	redef fun n_value=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_args)
		v.enter_visit(n_assign)
		v.enter_visit(n_value)
	end
end
redef class ABraReassignExpr
	private init empty_init do end

	init init_abrareassignexpr (
		nexpr: nullable AExpr,
		nargs: nullable AExprs,
		nassign_op: nullable AAssignOp,
		nvalue: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_args = nargs.as(not null)
		nargs.parent = self
		n_assign_op = nassign_op.as(not null)
		nassign_op.parent = self
		n_value = nvalue.as(not null)
		nvalue.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_args == old_child then
			n_args = new_child.as(AExprs)
			return
		end
		if n_assign_op == old_child then
			n_assign_op = new_child.as(AAssignOp)
			return
		end
		if n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_args=(node)
	do
		super
		node.parent = self
	end
	redef fun n_assign_op=(node)
	do
		super
		node.parent = self
	end
	redef fun n_value=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_args)
		v.enter_visit(n_assign_op)
		v.enter_visit(n_value)
	end
end
redef class AVarExpr
	private init empty_init do end

	init init_avarexpr (
		nid: nullable TId
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
	end
end
redef class AVarAssignExpr
	private init empty_init do end

	init init_avarassignexpr (
		nid: nullable TId,
		nassign: nullable TAssign,
		nvalue: nullable AExpr
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
		n_assign = nassign.as(not null)
		nassign.parent = self
		n_value = nvalue.as(not null)
		nvalue.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if n_assign == old_child then
			n_assign = new_child.as(TAssign)
			return
		end
		if n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_assign=(node)
	do
		super
		node.parent = self
	end
	redef fun n_value=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
		v.enter_visit(n_assign)
		v.enter_visit(n_value)
	end
end
redef class AVarReassignExpr
	private init empty_init do end

	init init_avarreassignexpr (
		nid: nullable TId,
		nassign_op: nullable AAssignOp,
		nvalue: nullable AExpr
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
		n_assign_op = nassign_op.as(not null)
		nassign_op.parent = self
		n_value = nvalue.as(not null)
		nvalue.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
		if n_assign_op == old_child then
			n_assign_op = new_child.as(AAssignOp)
			return
		end
		if n_value == old_child then
			n_value = new_child.as(AExpr)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end
	redef fun n_assign_op=(node)
	do
		super
		node.parent = self
	end
	redef fun n_value=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
		v.enter_visit(n_assign_op)
		v.enter_visit(n_value)
	end
end
redef class ARangeExpr
	private init empty_init do end

	init init_arangeexpr (
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
		v.enter_visit(n_annotations)
	end
end
redef class ACrangeExpr
	private init empty_init do end

	init init_acrangeexpr (
		nobra: nullable TObra,
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr,
		ncbra: nullable TCbra,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_obra = nobra.as(not null)
		nobra.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
		n_cbra = ncbra.as(not null)
		ncbra.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
		if n_cbra == old_child then
			n_cbra = new_child.as(TCbra)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_obra=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end
	redef fun n_cbra=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_obra)
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
		v.enter_visit(n_cbra)
		v.enter_visit(n_annotations)
	end
end
redef class AOrangeExpr
	private init empty_init do end

	init init_aorangeexpr (
		nobra: nullable TObra,
		nexpr: nullable AExpr,
		nexpr2: nullable AExpr,
		ncbra: nullable TObra,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_obra = nobra.as(not null)
		nobra.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_expr2 = nexpr2.as(not null)
		nexpr2.parent = self
		n_cbra = ncbra.as(not null)
		ncbra.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_expr2 == old_child then
			n_expr2 = new_child.as(AExpr)
			return
		end
		if n_cbra == old_child then
			n_cbra = new_child.as(TObra)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_obra=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr2=(node)
	do
		super
		node.parent = self
	end
	redef fun n_cbra=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_obra)
		v.enter_visit(n_expr)
		v.enter_visit(n_expr2)
		v.enter_visit(n_cbra)
		v.enter_visit(n_annotations)
	end
end
redef class AArrayExpr
	private init empty_init do end

	init init_aarrayexpr (
		nexprs: nullable AExprs,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_exprs = nexprs.as(not null)
		nexprs.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_exprs == old_child then
			n_exprs = new_child.as(AExprs)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_exprs=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_exprs)
		v.enter_visit(n_annotations)
	end
end
redef class ASelfExpr
	private init empty_init do end

	init init_aselfexpr (
		nkwself: nullable TKwself,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_kwself = nkwself.as(not null)
		nkwself.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwself == old_child then
			n_kwself = new_child.as(TKwself)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwself=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwself)
		v.enter_visit(n_annotations)
	end
end
redef class AImplicitSelfExpr
	private init empty_init do end

	init init_aimplicitselfexpr
	do
		empty_init
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
	end



	redef fun visit_all(v: Visitor)
	do
	end
end
redef class ATrueExpr
	private init empty_init do end

	init init_atrueexpr (
		nkwtrue: nullable TKwtrue,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_kwtrue = nkwtrue.as(not null)
		nkwtrue.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwtrue == old_child then
			n_kwtrue = new_child.as(TKwtrue)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwtrue=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwtrue)
		v.enter_visit(n_annotations)
	end
end
redef class AFalseExpr
	private init empty_init do end

	init init_afalseexpr (
		nkwfalse: nullable TKwfalse,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_kwfalse = nkwfalse.as(not null)
		nkwfalse.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwfalse == old_child then
			n_kwfalse = new_child.as(TKwfalse)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwfalse=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwfalse)
		v.enter_visit(n_annotations)
	end
end
redef class ANullExpr
	private init empty_init do end

	init init_anullexpr (
		nkwnull: nullable TKwnull,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_kwnull = nkwnull.as(not null)
		nkwnull.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwnull == old_child then
			n_kwnull = new_child.as(TKwnull)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_kwnull=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwnull)
		v.enter_visit(n_annotations)
	end
end
redef class ADecIntExpr
	private init empty_init do end

	init init_adecintexpr (
		nnumber: nullable TNumber,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_number = nnumber.as(not null)
		nnumber.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_number == old_child then
			n_number = new_child.as(TNumber)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_number=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_number)
		v.enter_visit(n_annotations)
	end
end
redef class AHexIntExpr
	private init empty_init do end

	init init_ahexintexpr (
		nhex_number: nullable THexNumber,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_hex_number = nhex_number.as(not null)
		nhex_number.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_hex_number == old_child then
			n_hex_number = new_child.as(THexNumber)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_hex_number=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_hex_number)
		v.enter_visit(n_annotations)
	end
end
redef class AFloatExpr
	private init empty_init do end

	init init_afloatexpr (
		nfloat: nullable TFloat,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_float = nfloat.as(not null)
		nfloat.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_float == old_child then
			n_float = new_child.as(TFloat)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_float=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_float)
		v.enter_visit(n_annotations)
	end
end
redef class ACharExpr
	private init empty_init do end

	init init_acharexpr (
		nchar: nullable TChar,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_char = nchar.as(not null)
		nchar.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_char == old_child then
			n_char = new_child.as(TChar)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_char=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_char)
		v.enter_visit(n_annotations)
	end
end
redef class AStringExpr
	private init empty_init do end

	init init_astringexpr (
		nstring: nullable TString,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_string = nstring.as(not null)
		nstring.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_string == old_child then
			n_string = new_child.as(TString)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_string=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_string)
		v.enter_visit(n_annotations)
	end
end
redef class AStartStringExpr
	private init empty_init do end

	init init_astartstringexpr (
		nstring: nullable TStartString
	)
	do
		empty_init
		n_string = nstring.as(not null)
		nstring.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_string == old_child then
			n_string = new_child.as(TStartString)
			return
		end
	end

	redef fun n_string=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_string)
	end
end
redef class AMidStringExpr
	private init empty_init do end

	init init_amidstringexpr (
		nstring: nullable TMidString
	)
	do
		empty_init
		n_string = nstring.as(not null)
		nstring.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_string == old_child then
			n_string = new_child.as(TMidString)
			return
		end
	end

	redef fun n_string=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_string)
	end
end
redef class AEndStringExpr
	private init empty_init do end

	init init_aendstringexpr (
		nstring: nullable TEndString
	)
	do
		empty_init
		n_string = nstring.as(not null)
		nstring.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_string == old_child then
			n_string = new_child.as(TEndString)
			return
		end
	end

	redef fun n_string=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_string)
	end
end
redef class ASuperstringExpr
	private init empty_init do end

	init init_asuperstringexpr (
		nexprs: Collection[Object], # Should be Collection[AExpr]
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_exprs.unsafe_add_all(nexprs)
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_exprs.replace_child(old_child, new_child) then return
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		n_exprs.visit_all(v)
		v.enter_visit(n_annotations)
	end
end
redef class AParExpr
	private init empty_init do end

	init init_aparexpr (
		nopar: nullable TOpar,
		nexpr: nullable AExpr,
		ncpar: nullable TCpar,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_opar = nopar.as(not null)
		nopar.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_cpar = ncpar.as(not null)
		ncpar.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_opar == old_child then
			n_opar = new_child.as(TOpar)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_cpar == old_child then
			n_cpar = new_child.as(TCpar)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_opar=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_cpar=(node)
	do
		super
		node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_opar)
		v.enter_visit(n_expr)
		v.enter_visit(n_cpar)
		v.enter_visit(n_annotations)
	end
end
redef class AAsCastExpr
	private init empty_init do end

	init init_aascastexpr (
		nexpr: nullable AExpr,
		nkwas: nullable TKwas,
		nopar: nullable TOpar,
		ntype: nullable AType,
		ncpar: nullable TCpar
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_kwas = nkwas.as(not null)
		nkwas.parent = self
		n_opar = nopar
		if nopar != null then nopar.parent = self
		n_type = ntype.as(not null)
		ntype.parent = self
		n_cpar = ncpar
		if ncpar != null then ncpar.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_kwas == old_child then
			n_kwas = new_child.as(TKwas)
			return
		end
		if n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwas=(node)
	do
		super
		node.parent = self
	end
	redef fun n_opar=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		node.parent = self
	end
	redef fun n_cpar=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_kwas)
		v.enter_visit(n_opar)
		v.enter_visit(n_type)
		v.enter_visit(n_cpar)
	end
end
redef class AAsNotnullExpr
	private init empty_init do end

	init init_aasnotnullexpr (
		nexpr: nullable AExpr,
		nkwas: nullable TKwas,
		nopar: nullable TOpar,
		nkwnot: nullable TKwnot,
		nkwnull: nullable TKwnull,
		ncpar: nullable TCpar
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_kwas = nkwas.as(not null)
		nkwas.parent = self
		n_opar = nopar
		if nopar != null then nopar.parent = self
		n_kwnot = nkwnot.as(not null)
		nkwnot.parent = self
		n_kwnull = nkwnull.as(not null)
		nkwnull.parent = self
		n_cpar = ncpar
		if ncpar != null then ncpar.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_kwas == old_child then
			n_kwas = new_child.as(TKwas)
			return
		end
		if n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if n_kwnot == old_child then
			n_kwnot = new_child.as(TKwnot)
			return
		end
		if n_kwnull == old_child then
			n_kwnull = new_child.as(TKwnull)
			return
		end
		if n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwas=(node)
	do
		super
		node.parent = self
	end
	redef fun n_opar=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwnot=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwnull=(node)
	do
		super
		node.parent = self
	end
	redef fun n_cpar=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
		v.enter_visit(n_kwas)
		v.enter_visit(n_opar)
		v.enter_visit(n_kwnot)
		v.enter_visit(n_kwnull)
		v.enter_visit(n_cpar)
	end
end
redef class AIssetAttrExpr
	private init empty_init do end

	init init_aissetattrexpr (
		nkwisset: nullable TKwisset,
		nexpr: nullable AExpr,
		nid: nullable TAttrid
	)
	do
		empty_init
		n_kwisset = nkwisset.as(not null)
		nkwisset.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwisset == old_child then
			n_kwisset = new_child.as(TKwisset)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_id == old_child then
			n_id = new_child.as(TAttrid)
			return
		end
	end

	redef fun n_kwisset=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwisset)
		v.enter_visit(n_expr)
		v.enter_visit(n_id)
	end
end
redef class ADebugTypeExpr
	private init empty_init do end

	init init_adebugtypeexpr (
		nkwdebug: nullable TKwdebug,
		nkwtype: nullable TKwtype,
		nexpr: nullable AExpr,
		ntype: nullable AType
	)
	do
		empty_init
		n_kwdebug = nkwdebug.as(not null)
		nkwdebug.parent = self
		n_kwtype = nkwtype.as(not null)
		nkwtype.parent = self
		n_expr = nexpr.as(not null)
		nexpr.parent = self
		n_type = ntype.as(not null)
		ntype.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwdebug == old_child then
			n_kwdebug = new_child.as(TKwdebug)
			return
		end
		if n_kwtype == old_child then
			n_kwtype = new_child.as(TKwtype)
			return
		end
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
	end

	redef fun n_kwdebug=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwtype=(node)
	do
		super
		node.parent = self
	end
	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end
	redef fun n_type=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwdebug)
		v.enter_visit(n_kwtype)
		v.enter_visit(n_expr)
		v.enter_visit(n_type)
	end
end
redef class AListExprs
	private init empty_init do end

	init init_alistexprs (
		nexprs: Collection[Object] # Should be Collection[AExpr]
	)
	do
		empty_init
		n_exprs.unsafe_add_all(nexprs)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_exprs.replace_child(old_child, new_child) then return
	end



	redef fun visit_all(v: Visitor)
	do
		n_exprs.visit_all(v)
	end
end
redef class AParExprs
	private init empty_init do end

	init init_aparexprs (
		nopar: nullable TOpar,
		nexprs: Collection[Object], # Should be Collection[AExpr]
		ncpar: nullable TCpar
	)
	do
		empty_init
		n_opar = nopar.as(not null)
		nopar.parent = self
		n_exprs.unsafe_add_all(nexprs)
		n_cpar = ncpar.as(not null)
		ncpar.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_opar == old_child then
			n_opar = new_child.as(TOpar)
			return
		end
		if n_exprs.replace_child(old_child, new_child) then return
		if n_cpar == old_child then
			n_cpar = new_child.as(TCpar)
			return
		end
	end

	redef fun n_opar=(node)
	do
		super
		node.parent = self
	end
	redef fun n_cpar=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_opar)
		n_exprs.visit_all(v)
		v.enter_visit(n_cpar)
	end
end
redef class ABraExprs
	private init empty_init do end

	init init_abraexprs (
		nobra: nullable TObra,
		nexprs: Collection[Object], # Should be Collection[AExpr]
		ncbra: nullable TCbra
	)
	do
		empty_init
		n_obra = nobra.as(not null)
		nobra.parent = self
		n_exprs.unsafe_add_all(nexprs)
		n_cbra = ncbra.as(not null)
		ncbra.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_obra == old_child then
			n_obra = new_child.as(TObra)
			return
		end
		if n_exprs.replace_child(old_child, new_child) then return
		if n_cbra == old_child then
			n_cbra = new_child.as(TCbra)
			return
		end
	end

	redef fun n_obra=(node)
	do
		super
		node.parent = self
	end
	redef fun n_cbra=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_obra)
		n_exprs.visit_all(v)
		v.enter_visit(n_cbra)
	end
end
redef class APlusAssignOp
	private init empty_init do end

	init init_aplusassignop (
		npluseq: nullable TPluseq
	)
	do
		empty_init
		n_pluseq = npluseq.as(not null)
		npluseq.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_pluseq == old_child then
			n_pluseq = new_child.as(TPluseq)
			return
		end
	end

	redef fun n_pluseq=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_pluseq)
	end
end
redef class AMinusAssignOp
	private init empty_init do end

	init init_aminusassignop (
		nminuseq: nullable TMinuseq
	)
	do
		empty_init
		n_minuseq = nminuseq.as(not null)
		nminuseq.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_minuseq == old_child then
			n_minuseq = new_child.as(TMinuseq)
			return
		end
	end

	redef fun n_minuseq=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_minuseq)
	end
end
redef class AModuleName
	private init empty_init do end

	init init_amodulename (
		nquad: nullable TQuad,
		npath: Collection[Object], # Should be Collection[TId]
		nid: nullable TId
	)
	do
		empty_init
		n_quad = nquad
		if nquad != null then nquad.parent = self
		n_path.unsafe_add_all(npath)
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_quad == old_child then
			n_quad = new_child.as(nullable TQuad)
			return
		end
		if n_path.replace_child(old_child, new_child) then return
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
	end

	redef fun n_quad=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_quad)
		n_path.visit_all(v)
		v.enter_visit(n_id)
	end
end
redef class AExternCalls
	private init empty_init do end

	init init_aexterncalls (
		nkwimport: nullable TKwimport,
		nextern_calls: Collection[Object] # Should be Collection[AExternCall]
	)
	do
		empty_init
		n_kwimport = nkwimport.as(not null)
		nkwimport.parent = self
		n_extern_calls.unsafe_add_all(nextern_calls)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwimport == old_child then
			n_kwimport = new_child.as(TKwimport)
			return
		end
		if n_extern_calls.replace_child(old_child, new_child) then return
	end

	redef fun n_kwimport=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwimport)
		n_extern_calls.visit_all(v)
	end
end
redef class AExternCall
	private init empty_init do end

	init init_aexterncall
	do
		empty_init
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
	end



	redef fun visit_all(v: Visitor)
	do
	end
end
redef class ASuperExternCall
	private init empty_init do end

	init init_asuperexterncall (
		nkwsuper: nullable TKwsuper
	)
	do
		empty_init
		n_kwsuper = nkwsuper.as(not null)
		nkwsuper.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwsuper == old_child then
			n_kwsuper = new_child.as(TKwsuper)
			return
		end
	end

	redef fun n_kwsuper=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwsuper)
	end
end
redef class ALocalPropExternCall
	private init empty_init do end

	init init_alocalpropexterncall (
		nmethid: nullable AMethid
	)
	do
		empty_init
		n_methid = nmethid.as(not null)
		nmethid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_methid == old_child then
			n_methid = new_child.as(AMethid)
			return
		end
	end

	redef fun n_methid=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_methid)
	end
end
redef class AFullPropExternCall
	private init empty_init do end

	init init_afullpropexterncall (
		ntype: nullable AType,
		ndot: nullable TDot,
		nmethid: nullable AMethid
	)
	do
		empty_init
		n_type = ntype.as(not null)
		ntype.parent = self
		n_dot = ndot
		if ndot != null then ndot.parent = self
		n_methid = nmethid.as(not null)
		nmethid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if n_dot == old_child then
			n_dot = new_child.as(nullable TDot)
			return
		end
		if n_methid == old_child then
			n_methid = new_child.as(AMethid)
			return
		end
	end

	redef fun n_type=(node)
	do
		super
		node.parent = self
	end
	redef fun n_dot=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_methid=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_type)
		v.enter_visit(n_dot)
		v.enter_visit(n_methid)
	end
end
redef class AInitPropExternCall
	private init empty_init do end

	init init_ainitpropexterncall (
		ntype: nullable AType
	)
	do
		empty_init
		n_type = ntype.as(not null)
		ntype.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
	end

	redef fun n_type=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_type)
	end
end
redef class ACastAsExternCall
	private init empty_init do end

	init init_acastasexterncall (
		nfrom_type: nullable AType,
		ndot: nullable TDot,
		nkwas: nullable TKwas,
		nto_type: nullable AType
	)
	do
		empty_init
		n_from_type = nfrom_type.as(not null)
		nfrom_type.parent = self
		n_dot = ndot
		if ndot != null then ndot.parent = self
		n_kwas = nkwas.as(not null)
		nkwas.parent = self
		n_to_type = nto_type.as(not null)
		nto_type.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_from_type == old_child then
			n_from_type = new_child.as(AType)
			return
		end
		if n_dot == old_child then
			n_dot = new_child.as(nullable TDot)
			return
		end
		if n_kwas == old_child then
			n_kwas = new_child.as(TKwas)
			return
		end
		if n_to_type == old_child then
			n_to_type = new_child.as(AType)
			return
		end
	end

	redef fun n_from_type=(node)
	do
		super
		node.parent = self
	end
	redef fun n_dot=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_kwas=(node)
	do
		super
		node.parent = self
	end
	redef fun n_to_type=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_from_type)
		v.enter_visit(n_dot)
		v.enter_visit(n_kwas)
		v.enter_visit(n_to_type)
	end
end
redef class AAsNullableExternCall
	private init empty_init do end

	init init_aasnullableexterncall (
		ntype: nullable AType,
		nkwas: nullable TKwas,
		nkwnullable: nullable TKwnullable
	)
	do
		empty_init
		n_type = ntype.as(not null)
		ntype.parent = self
		n_kwas = nkwas.as(not null)
		nkwas.parent = self
		n_kwnullable = nkwnullable.as(not null)
		nkwnullable.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if n_kwas == old_child then
			n_kwas = new_child.as(TKwas)
			return
		end
		if n_kwnullable == old_child then
			n_kwnullable = new_child.as(TKwnullable)
			return
		end
	end

	redef fun n_type=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwas=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwnullable=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_type)
		v.enter_visit(n_kwas)
		v.enter_visit(n_kwnullable)
	end
end
redef class AAsNotNullableExternCall
	private init empty_init do end

	init init_aasnotnullableexterncall (
		ntype: nullable AType,
		nkwas: nullable TKwas,
		nkwnot: nullable TKwnot,
		nkwnullable: nullable TKwnullable
	)
	do
		empty_init
		n_type = ntype.as(not null)
		ntype.parent = self
		n_kwas = nkwas.as(not null)
		nkwas.parent = self
		n_kwnot = nkwnot.as(not null)
		nkwnot.parent = self
		n_kwnullable = nkwnullable.as(not null)
		nkwnullable.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
		if n_kwas == old_child then
			n_kwas = new_child.as(TKwas)
			return
		end
		if n_kwnot == old_child then
			n_kwnot = new_child.as(TKwnot)
			return
		end
		if n_kwnullable == old_child then
			n_kwnullable = new_child.as(TKwnullable)
			return
		end
	end

	redef fun n_type=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwas=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwnot=(node)
	do
		super
		node.parent = self
	end
	redef fun n_kwnullable=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_type)
		v.enter_visit(n_kwas)
		v.enter_visit(n_kwnot)
		v.enter_visit(n_kwnullable)
	end
end
redef class AInLanguage
	private init empty_init do end

	init init_ainlanguage (
		nkwin: nullable TKwin,
		nstring: nullable TString
	)
	do
		empty_init
		n_kwin = nkwin.as(not null)
		nkwin.parent = self
		n_string = nstring.as(not null)
		nstring.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_kwin == old_child then
			n_kwin = new_child.as(TKwin)
			return
		end
		if n_string == old_child then
			n_string = new_child.as(TString)
			return
		end
	end

	redef fun n_kwin=(node)
	do
		super
		node.parent = self
	end
	redef fun n_string=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_kwin)
		v.enter_visit(n_string)
	end
end
redef class AExternCodeBlock
	private init empty_init do end

	init init_aexterncodeblock (
		nin_language: nullable AInLanguage,
		nextern_code_segment: nullable TExternCodeSegment
	)
	do
		empty_init
		n_in_language = nin_language
		if nin_language != null then nin_language.parent = self
		n_extern_code_segment = nextern_code_segment.as(not null)
		nextern_code_segment.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_in_language == old_child then
			n_in_language = new_child.as(nullable AInLanguage)
			return
		end
		if n_extern_code_segment == old_child then
			n_extern_code_segment = new_child.as(TExternCodeSegment)
			return
		end
	end

	redef fun n_in_language=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_extern_code_segment=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_in_language)
		v.enter_visit(n_extern_code_segment)
	end
end
redef class AQualified
	private init empty_init do end

	init init_aqualified (
		nid: Collection[Object], # Should be Collection[TId]
		nclassid: nullable TClassid
	)
	do
		empty_init
		n_id.unsafe_add_all(nid)
		n_classid = nclassid
		if nclassid != null then nclassid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id.replace_child(old_child, new_child) then return
		if n_classid == old_child then
			n_classid = new_child.as(nullable TClassid)
			return
		end
	end

	redef fun n_classid=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		n_id.visit_all(v)
		v.enter_visit(n_classid)
	end
end
redef class ADoc
	private init empty_init do end

	init init_adoc (
		ncomment: Collection[Object] # Should be Collection[TComment]
	)
	do
		empty_init
		n_comment.unsafe_add_all(ncomment)
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_comment.replace_child(old_child, new_child) then return
	end



	redef fun visit_all(v: Visitor)
	do
		n_comment.visit_all(v)
	end
end
redef class AAnnotations
	private init empty_init do end

	init init_aannotations (
		nat: nullable TAt,
		nopar: nullable TOpar,
		nitems: Collection[Object], # Should be Collection[AAnnotation]
		ncpar: nullable TCpar
	)
	do
		empty_init
		n_at = nat
		if nat != null then nat.parent = self
		n_opar = nopar
		if nopar != null then nopar.parent = self
		n_items.unsafe_add_all(nitems)
		n_cpar = ncpar
		if ncpar != null then ncpar.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_at == old_child then
			n_at = new_child.as(nullable TAt)
			return
		end
		if n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if n_items.replace_child(old_child, new_child) then return
		if n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
	end

	redef fun n_at=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_opar=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_cpar=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_at)
		v.enter_visit(n_opar)
		n_items.visit_all(v)
		v.enter_visit(n_cpar)
	end
end
redef class AAnnotation
	private init empty_init do end

	init init_aannotation (
		natid: nullable AAtid,
		nopar: nullable TOpar,
		nargs: Collection[Object], # Should be Collection[AAtArg]
		ncpar: nullable TCpar,
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_atid = natid.as(not null)
		natid.parent = self
		n_opar = nopar
		if nopar != null then nopar.parent = self
		n_args.unsafe_add_all(nargs)
		n_cpar = ncpar
		if ncpar != null then ncpar.parent = self
		n_annotations = nannotations
		if nannotations != null then nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_atid == old_child then
			n_atid = new_child.as(AAtid)
			return
		end
		if n_opar == old_child then
			n_opar = new_child.as(nullable TOpar)
			return
		end
		if n_args.replace_child(old_child, new_child) then return
		if n_cpar == old_child then
			n_cpar = new_child.as(nullable TCpar)
			return
		end
		if n_annotations == old_child then
			n_annotations = new_child.as(nullable AAnnotations)
			return
		end
	end

	redef fun n_atid=(node)
	do
		super
		node.parent = self
	end
	redef fun n_opar=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_cpar=(node)
	do
		super
		if node != null then node.parent = self
	end
	redef fun n_annotations=(node)
	do
		super
		if node != null then node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_atid)
		v.enter_visit(n_opar)
		n_args.visit_all(v)
		v.enter_visit(n_cpar)
		v.enter_visit(n_annotations)
	end
end
redef class ATypeAtArg
	private init empty_init do end

	init init_atypeatarg (
		ntype: nullable AType
	)
	do
		empty_init
		n_type = ntype.as(not null)
		ntype.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_type == old_child then
			n_type = new_child.as(AType)
			return
		end
	end

	redef fun n_type=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_type)
	end
end
redef class AExprAtArg
	private init empty_init do end

	init init_aexpratarg (
		nexpr: nullable AExpr
	)
	do
		empty_init
		n_expr = nexpr.as(not null)
		nexpr.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_expr == old_child then
			n_expr = new_child.as(AExpr)
			return
		end
	end

	redef fun n_expr=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_expr)
	end
end
redef class AAtAtArg
	private init empty_init do end

	init init_aatatarg (
		nannotations: nullable AAnnotations
	)
	do
		empty_init
		n_annotations = nannotations.as(not null)
		nannotations.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_annotations == old_child then
			n_annotations = new_child.as(AAnnotations)
			return
		end
	end

	redef fun n_annotations=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_annotations)
	end
end
redef class AIdAtid
	private init empty_init do end

	init init_aidatid (
		nid: nullable TId
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TId)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
	end
end
redef class AKwexternAtid
	private init empty_init do end

	init init_akwexternatid (
		nid: nullable TKwextern
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TKwextern)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
	end
end
redef class AKwinternAtid
	private init empty_init do end

	init init_akwinternatid (
		nid: nullable TKwintern
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TKwintern)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
	end
end
redef class AKwreadableAtid
	private init empty_init do end

	init init_akwreadableatid (
		nid: nullable TKwreadable
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TKwreadable)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
	end
end
redef class AKwwritableAtid
	private init empty_init do end

	init init_akwwritableatid (
		nid: nullable TKwwritable
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TKwwritable)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
	end
end
redef class AKwimportAtid
	private init empty_init do end

	init init_akwimportatid (
		nid: nullable TKwimport
	)
	do
		empty_init
		n_id = nid.as(not null)
		nid.parent = self
	end

	redef fun replace_child(old_child: ANode, new_child: nullable ANode)
	do
		if n_id == old_child then
			n_id = new_child.as(TKwimport)
			return
		end
	end

	redef fun n_id=(node)
	do
		super
		node.parent = self
	end


	redef fun visit_all(v: Visitor)
	do
		v.enter_visit(n_id)
	end
end

redef class Start
    redef fun replace_child(old_child: ANode, new_child: nullable ANode)
    do
        if n_base == old_child then
            if new_child == null then
            else
                new_child.parent = self
		assert new_child isa AModule
                n_base = new_child
            end
            old_child.parent = null
            return
	end
    end

    redef fun visit_all(v: Visitor)
    do
        if n_base != null then
            v.enter_visit(n_base.as(not null))
        end
	v.enter_visit(n_eof)
    end
end
